<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Retro Platforms â€” Enhanced & Hybrid</title>
<style>
:root{
  --sky:#87ceeb; --ground:#6b4f2a; --ground-top:#8f6b3a;
  --player:#3498db; --enemy:#e67e22; --turtle:#16a085; --flier:#9b59b6; --shooter:#e74c3c;
  --spike:#c0392b; --goal:#2ecc71; --spring:#5dade2; --water:#3aa6ffcc;
  --coin:#f1c40f; 
  --ui:#000000cc; --text:#fff;
  --btn-width: 70px; /* ØªØ­Ø³ÙŠÙ† Ø£Ø¨Ø¹Ø§Ø¯ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù„Ù…Ø³ */
  --btn-spacing: 12px;
}
html,body{margin:0;background:#0d1117;color:var(--text);font-family:system-ui,Segoe UI,Roboto;overscroll-behavior: none;}
#game{display:block;margin:0 auto;background:var(--sky);image-rendering:pixelated;outline:none}
.topbar{position:fixed;top:8px;left:8px;right:8px;display:flex;gap:8px;align-items:center;z-index:5}
.panel{background:var(--ui);padding:8px 12px;border-radius:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grow{flex:1}
.btn{appearance:none;border:0;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
.btn.primary{background:#2ecc71;color:#062}
.btn.ghost{background:#ffffff10;color:#fff;border:1px solid #ffffff33}
.centered{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(2px);background:#0008;z-index:10}
.touch{position:fixed;bottom:var(--btn-spacing);left:var(--btn-spacing);right:var(--btn-spacing);display:flex;justify-content:space-between;gap:var(--btn-spacing);pointer-events:none;z-index:4}

/* ØªØ­Ø³ÙŠÙ† ØªØµÙ…ÙŠÙ… Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù„Ù…Ø³ ÙˆÙ…ÙˆØ§Ø¶Ø¹Ù‡Ø§ */
.pad{display:flex;gap:var(--btn-spacing);}
.tbtn{
  width:var(--btn-width); height:var(--btn-width); 
  border-radius:50%; background:#ffffff22; border:2px solid #ffffff55;
  pointer-events:auto; touch-action:none; user-select:none; backdrop-filter:blur(6px);
  color:#fff; font-size:24px; font-weight:900;
  display: flex; align-items: center; justify-content: center;
}
/* Ø¹ÙƒØ³ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø£Ø²Ø±Ø§Ø±: Ø§Ù„Ø­Ø±ÙƒØ© Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±ØŒ Ø§Ù„Ø£ÙƒØ´Ù† Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ† */
.touch > .pad:first-child { 
    order: 1; /* Ø§Ù„Ø­Ø±ÙƒØ© (ÙŠÙ…ÙŠÙ† ÙŠØ³Ø§Ø±) */
    flex-basis: calc(2 * var(--btn-width) + var(--btn-spacing)); 
    justify-content: flex-start;
}
.touch > .pad:last-child { 
    order: 2; /* Ø§Ù„Ù‚ÙØ² ÙˆØ§Ù„Ø§Ø·Ù„Ø§Ù‚ */
    flex-basis: calc(2 * var(--btn-width) + var(--btn-spacing)); 
    justify-content: flex-end;
}
/* ØªØµÙ…ÙŠÙ… Ø¹ØµÙŠ Ø§Ù„ØªØ­ÙƒÙ… (D-Pad style) Ù„Ù„Ø­Ø±ÙƒØ© */
#btnLeft { border-radius: 50% 10% 10% 50%; }
#btnRight { border-radius: 10% 50% 50% 10%; }
/* ØªØ±ØªÙŠØ¨ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ù„ÙŠØµØ¨Ø­ Ø§Ù„ÙŠØ³Ø§Ø± Ø«Ù… Ø§Ù„ÙŠÙ…ÙŠÙ† */
#btnLeft{order: 1;}
#btnRight{order: 2;}
/* ØªØ±ØªÙŠØ¨ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£ÙƒØ´Ù† Ù„ÙŠØµØ¨Ø­ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø«Ù… Ø§Ù„Ù‚ÙØ² */
#btnShoot{order: 1;}
#btnJump{order: 2;}


@media (min-width:900px){.touch{display:none}}
.hearts{letter-spacing:2px}
.hint{opacity:.8;font-size:12px;margin-top:6px}
.badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#ffffff22;border:1px solid #ffffff33}
.splash{width:min(900px,92vw);max-width:92vw;border-radius:16px;overflow:hidden;box-shadow:0 20px 60px #000a}
.splash-head{position:relative;height:min(340px,48vh);background:
  radial-gradient(1000px 280px at 20% 0%, #6ec5ff33 0%, transparent 60%),
  radial-gradient(800px 260px at 90% 10%, #e0a3ff33 0%, transparent 55%),
  linear-gradient(180deg,#223 0%,#112 100%);display:flex;align-items:center;justify-content:center}
.splash-canvas{position:absolute;inset:0}
.splash-title{position:relative;z-index:2;font-size:clamp(24px,5.2vw,44px);font-weight:900;letter-spacing:1px;color:#e8f7ff;text-shadow:0 2px 0 #0008,0 0 24px #69d1ff77}
.splash-body{background:#0b0f18;padding:14px}

/* Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ØªØ¬Ø± */
.shop-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-top: 15px; }
.shop-item { background: #1a1e27; padding: 10px; border-radius: 8px; text-align: center; border: 1px solid #333; }
.shop-item h4 { margin: 0 0 5px 0; color: var(--text); }
.shop-item p { margin: 0 0 10px 0; font-size: 14px; color: #aaa; }
.shop-cost { font-weight: bold; color: var(--coin); display: block; margin-bottom: 8px;}
</style>
</head>
<body>
  <div class="topbar">
    <div class="panel grow" id="hudLeft">
      <span id="hearts" class="hearts">â¤â¤â¤</span>
      <span id="shield" class="hint">ğŸ›¡ 0</span>
      <span id="coins" style="color:var(--coin); font-weight:bold;">ğŸ’° 0</span> <span id="stage" class="badge">L1</span>
    </div>
    <div class="panel" id="hudRight">
      <button class="btn ghost" id="btnShop" title="Ø§Ù„Ù…ØªØ¬Ø±">ğŸ›’</button> <button class="btn ghost" id="btnLang">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</button>
      <button class="btn ghost" id="btnMusic">ğŸ”‡</button>
      <button class="btn ghost" id="btnPause">â¸ï¸</button>
    </div>
  </div>

  <canvas id="game" width="960" height="540" tabindex="0" aria-label="Game canvas"></canvas>

  <div class="touch" id="touch">
    <div class="pad">
      <button class="tbtn" id="btnLeft">â—€</button>
      <button class="tbtn" id="btnRight">â–¶</button>
    </div>
    <div class="pad">
      <button class="tbtn" id="btnShoot">âœ¹</button>
      <button class="tbtn" id="btnJump">â¤Š</button>
    </div>
  </div>

  <template id="tplOverlay">
    <div class="centered" id="overlay">
      <div class="panel" style="min-width:min(720px,94vw);text-align:center;max-height:90vh;overflow:auto">
        <div id="ovTitle" style="font-size:24px;font-weight:900;margin-bottom:8px">â€”</div>
        <div id="ovBody" style="line-height:1.6;margin-bottom:12px">â€”</div>
        <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap" id="ovButtons"></div>
        <div class="hint" id="ovHint">â† â†’ move, Space/W jump, F shoot, Esc pause</div>
      </div>
    </div>
  </template>

<script>
(()=>{'use strict';

/* ================= I18N ================= */
const I18N={
  ar:{title:'Ù…Ù†ØµØ§Øª Ù…ØªØ·ÙˆØ±Ø© - Ù‡Ø¬ÙŠÙ†',desc:'10 Ù…Ø±Ø§Ø­Ù„ Ø£Ø³Ø§Ø³ÙŠØ© Ù…Ø¨Ø±Ù…Ø¬Ø© Ø¨ØªØ­Ø¯ÙŠØ§Øª Ù…ØªÙ†ÙˆØ¹Ø©. Ø§Ø¬Ù…Ø¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª ğŸ’° Ù„Ø´Ø±Ø§Ø¡ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¯Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ù…ØªØ¬Ø± ğŸ›’. Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„ØªØ­ÙƒÙ… Ù…Ø­Ø³Ù†Ø§Ù† Ù„Ù„Ù‡ÙˆØ§ØªÙ. Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø³Ø§Ø±Ø©.',
      start:'Ø§Ø¨Ø¯Ø£ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©', cont:'Ù…ØªØ§Ø¨Ø¹Ø©', paused:'Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª', resume:'Ù…ØªØ§Ø¨Ø¹Ø©', restart:'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø±Ø­Ù„Ø©', menu:'Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©', shop:'Ø§Ù„Ù…ØªØ¬Ø±',
      lose:'Ø®Ø³Ø±Øª', stage:n=>`Ù…Ø±Ø­Ù„Ø© ${n}`, hint:'ÙƒÙŠØ¨ÙˆØ±Ø¯: â† â†’ Ù„Ù„Ø­Ø±ÙƒØ©ØŒ Space/W Ù„Ù„Ù‚ÙØ²ØŒ F Ù„Ù„Ø¥Ø·Ù„Ø§Ù‚ØŒ Esc Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù',
      drops:'Ø§Ù„ØªØ¹Ø²ÙŠØ²Ø§Øª: â¤ Ù‚Ù„Ø¨ | ğŸ›¡ Ø¯Ø±Ø¹ | â‡¥ Ø³Ø±Ø¹Ø© | â¤Š Ù‚ÙØ²',
      shop_title:'Ù…ØªØ¬Ø± Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª',
      shop_desc:'Ø£Ù†ÙÙ‚ Ø§Ù„Ø¹Ù…Ù„Ø§Øª ğŸ’° Ù„Ø²ÙŠØ§Ø¯Ø© Ù‚ÙˆØªÙƒ Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù…!'},
  en:{title:'Advanced Platforms - Hybrid',desc:'10 built-in levels with varied challenges. Collect coins ğŸ’° to buy permanent upgrades from the Shop ğŸ›’. Optimized performance and controls for mobile devices. Auto-save and level restart on death.',
      start:'Start New', cont:'Continue', paused:'Paused', resume:'Resume', restart:'Restart', menu:'Main Menu', shop:'Shop',
      lose:'You Lost', stage:n=>`Level ${n}`, hint:'Keyboard: â† â†’ move, Space/W jump, F shoot, Esc pause',
      drops:'Boosts: â¤ Heart | ğŸ›¡ Shield | â‡¥ Speed | â¤Š Jump',
      shop_title:'Upgrades Shop',
      shop_desc:'Spend Coins ğŸ’° to permanently increase your power!'}
};
let lang='ar'; const T=(k,...a)=> typeof I18N[lang][k]==='function'?I18N[lang][k](...a):I18N[lang][k];

/* ================ CONFIG & RUNTIME ================ */
const CFG={
  viewW:960, viewH:540, tile:32,
  // Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ© Ù…Ø­Ø³Ù†Ø© Ù„Ø­Ø±ÙƒØ© Ø£ÙƒØ«Ø± ÙˆØ§Ù‚Ø¹ÙŠØ© ÙˆØ§Ø³ØªØ¬Ø§Ø¨Ø©
  gravity:0.8, moveAcc:1.2, maxDX:6.0, maxDY:20, friction:0.88, jumpV:13.5, 
  coyoteTime:0.12, jumpBuffer:0.18, variableJumpCut:0.4, cameraLerp:0.12,
  springV:16,
  enemy:{walkerSpeed:1.1,turtleSpeed:0.95,flierSpeed:1.25,shooterSpeed:0.75,bulletSpeed:3.2,fireRate:2.6},
  player:{maxHearts:6,shootCooldown:0.28,bulletSpeed:6.6},
  scaling:{bandSize:5, enemySpeedMul:1.07, enemyFireRateMul:0.96, enemyBulletSpeedMul:1.06, playerSpeedMul:1.05, playerJumpMul:1.04, playerBulletSpeedMul:1.04},
  vibration:true,
  // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¥Ù„Ù‰ 10
  basicLevelCount: 10,
  jsonFiles: ['sentences1.json', 'sentences2.json', 'sentences3.json', 'sentences4.json']
};

const SHOP_ITEMS = [
    { id: 'bulletDmg', cost: 10, max: 5, stat: 'playerBulletSpeed', initial: 1, inc: 0.2, title_ar: 'Ù‚ÙˆØ© Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚', title_en: 'Bullet Power', desc_ar: 'ÙŠØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© ÙˆØªØ£Ø«ÙŠØ± Ø§Ù„Ø±ØµØ§Øµ.', desc_en: 'Increases bullet speed and impact.' },
    { id: 'maxHp', cost: 20, max: 2, stat: 'maxHearts', initial: CFG.player.maxHearts, inc: 1, title_ar: 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù‚Ù„ÙˆØ¨', title_en: 'Max Hearts', desc_ar: 'ÙŠØ²ÙŠØ¯ Ø¹Ø¯Ø¯ Ù‚Ù„ÙˆØ¨Ùƒ Ø§Ù„Ù‚ØµÙˆÙ‰ Ø¨Ù‚Ù„Ø¨ ÙˆØ§Ø­Ø¯.', desc_en: 'Increases your maximum health by one heart.' },
    { id: 'shieldCapacity', cost: 15, max: 3, stat: 'maxShields', initial: 0, inc: 1, title_ar: 'Ø³Ø¹Ø© Ø§Ù„Ø¯Ø±Ø¹', title_en: 'Shield Capacity', desc_ar: 'ÙŠØ²ÙŠØ¯ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¯Ø±ÙˆØ¹ Ø§Ù„Ù…Ø­Ù…ÙˆÙ„Ø©.', desc_en: 'Increases maximum carried shields.' },
];
// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…ØªØ¬Ø± Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† Ù„Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹
const SHOP_MAP = SHOP_ITEMS.reduce((map, item) => (map[item.id] = item, map), {});


const runtime={enemy:{...CFG.enemy}, player:{maxDX:CFG.maxDX,jumpV:CFG.jumpV,bulletSpeed:CFG.player.bulletSpeed}};

/* ================ DOM & HUD ================ */
const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
const tplOverlay=document.getElementById('tplOverlay');
const HUD={
  hearts:document.getElementById('hearts'), shield:document.getElementById('shield'), stage:document.getElementById('stage'),
  coins:document.getElementById('coins'), 
  btnPause:document.getElementById('btnPause'), btnLang:document.getElementById('btnLang'), btnMusic:document.getElementById('btnMusic'),
  btnShop:document.getElementById('btnShop') 
};
const TOUCH={ left:document.getElementById('btnLeft'), right:document.getElementById('btnRight'), jump:document.getElementById('btnJump'), shoot:document.getElementById('btnShoot') };

/* ================ UTILS ================ */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const rects=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
const vibrate=ms=>{ if(CFG.vibration&&navigator.vibrate) navigator.vibrate(ms); };
const nowSec=()=>performance.now()/1000;
function rnd(seed){ return (Math.sin(seed*12.9898)*43758.5453)%1; }

/* ================ AUDIO (Simplified for SFX Only) ================ */
let audioCtx=null, muted=true; 
function ensureAudio(){ if(!audioCtx){ try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch{} } }
function sfx(type='sine',f=440,dur=0.08,g=0.07){ if(muted) return; ensureAudio(); if(!audioCtx) return;
  const t0=audioCtx.currentTime,o=audioCtx.createOscillator(),ga=audioCtx.createGain();
  o.type=type; o.frequency.value=f; ga.gain.value=g; ga.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
  o.connect(ga).connect(audioCtx.destination); o.start(t0); o.stop(t0+dur);
}
const SFX={ jump:()=>sfx('square',520,0.09,0.08), pick:()=>sfx('triangle',900,0.08,0.06), hit:()=>sfx('sawtooth',180,0.12,0.07),
  win:()=>{ sfx('square',660,0.16,0.08); setTimeout(()=>sfx('square',880,0.13,0.06),120); }, spring:()=>sfx('triangle',720,0.1,0.07), shoot:()=>sfx('square',720,0.06,0.06),
  coin:()=>sfx('triangle',1200,0.04,0.05), 
  purchase:()=>sfx('square',1500,0.08,0.08) 
};

/* ================ INPUT ================ */
const keys={left:false,right:false,jump:false,shoot:false};
function wantFocus(){ ensureAudio(); canvas.focus(); }
addEventListener('keydown',e=>{
  if(['ArrowLeft','KeyA'].includes(e.code)) keys.left=true;
  if(['ArrowRight','KeyD'].includes(e.code)) keys.right=true;
  if(['Space','KeyW'].includes(e.code)){ keys.jump=true; wantFocus(); }
  if(e.code==='KeyF'){ keys.shoot=true; wantFocus(); }
  if(e.code==='Escape') togglePause();
});
addEventListener('keyup',e=>{
  if(['ArrowLeft','KeyA'].includes(e.code)) keys.left=false;
  if(['ArrowRight','KeyD'].includes(e.code)) keys.right=false;
  if(['Space','KeyW'].includes(e.code)) keys.jump=false;
  if(e.code==='KeyF') keys.shoot=false;
});
['left','right','jump','shoot'].forEach(k=>{
  const b=TOUCH[k];
  b.addEventListener('pointerdown',e=>{ e.preventDefault(); keys[k]=true; vibrate(15); wantFocus(); });
  ['pointerup','pointerleave','pointercancel'].forEach(ev=> b.addEventListener(ev,e=>{ e.preventDefault(); keys[k]=false; }));
});
HUD.btnMusic.textContent='ğŸ”‡';
HUD.btnMusic.addEventListener('click',()=>{ muted=!muted; HUD.btnMusic.textContent=muted?'ğŸ”‡':'ğŸ”Š'; });
HUD.btnLang.addEventListener('click',()=>{ 
    lang=(lang==='ar'?'en':'ar'); 
    document.documentElement.lang=lang; 
    document.documentElement.dir=(lang==='ar'?'rtl':'ltr'); 
    HUD.btnLang.textContent=(lang==='ar'?'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©':'English'); 
    updateHUD(); 
    if(state.scene==='menu') startMenu(); 
    if(state.scene==='pause'){ hideOverlay(); togglePause(); } 
    if(state.scene==='shop'){ hideOverlay(); showShop(); }
});
HUD.btnPause.addEventListener('click',()=>togglePause());
HUD.btnShop.addEventListener('click',()=>showShop()); 
addEventListener('pointerdown',onceKick,{once:true}); addEventListener('keydown',onceKick,{once:true});
function onceKick(){ wantFocus(); }

/* ================ WORLD & STATE ================ */
const TILE={EMPTY:0,SOLID:1,SPIKE:2,SPRING:3,GOAL:4,WATER:5,MOVING:6, COIN:7}; 
const ENEMY={WALKER:0,TURTLE:1,FLIER:2,SHOOTER:3};
const SAVEKEY='retro_procedural_v5_final';

const state={
    scene:'menu', level:0, band:0, camX:0, camY:0, 
    hearts:3, shield:0, coins:0, 
    hasGun:true, overlayEl:null, lastShotAt:-999, 
    boosts:{speed:0,jump:0},
    upgrades: SHOP_ITEMS.reduce((acc, item) => (acc[item.id] = 0, acc), {}) 
};

const player={x:0,y:0,w:24,h:30,dx:0,dy:0,on:false,coyote:0,jumpBuf:0,inv:0,facing:1};
let enemies=[], eBullets=[], pBullets=[], movingPlatforms=[], drops=[], currentLevelData=null;

/* ================ SAVE/LOAD ================ */
function saveProgress(){ try{
  localStorage.setItem(SAVEKEY, JSON.stringify({
    level: state.level, hearts: state.hearts, shield: state.shield,
    boosts: state.boosts, lang, coins: state.coins, upgrades: state.upgrades 
  }));
}catch{}}
function loadProgress(){ try{
  const s=JSON.parse(localStorage.getItem(SAVEKEY)||'null'); if(!s) return false;
  state.level=Number.isFinite(s.level)?s.level:0; state.hearts=s.hearts||3; state.shield=s.shield||0; state.boosts=s.boosts||{speed:0,jump:0};
  state.coins=s.coins||0; 
  state.upgrades=s.upgrades||SHOP_ITEMS.reduce((acc, item) => (acc[item.id] = 0, acc), {}); 
  lang=s.lang||lang; document.documentElement.lang=lang; document.documentElement.dir=(lang==='ar'?'rtl':'ltr'); HUD.btnLang.textContent=(lang==='ar'?'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©':'English');
  applyUpgrades(); 
  return true;
}catch{ return false; }}

/* ================ UPGRADES & SHOP ================ */
function applyUpgrades(){
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù‚Ù„ÙˆØ¨
    CFG.player.maxHearts = 6 + (state.upgrades.maxHp * SHOP_MAP.maxHp.inc);
    
    // Ø³Ø±Ø¹Ø© Ø§Ù„Ø±ØµØ§Øµ
    const bulletInc = state.upgrades.bulletDmg * SHOP_MAP.bulletDmg.inc;
    // ÙŠØªÙ… Ø¶Ø±Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (CFG.player.bulletSpeed) ÙÙŠ Ù†Ø³Ø¨Ø© Ø§Ù„Ø²ÙŠØ§Ø¯Ø© Ù…Ù† Ø§Ù„ØªØ±Ù‚ÙŠØ©
    runtime.player.bulletSpeed = CFG.player.bulletSpeed * (1 + bulletInc);
    
    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ© Ø§Ù„ØªÙŠ Ù‚Ø¯ ØªØªØ£Ø«Ø± Ø¨Ø§Ù„Ù€ Band Scaling Ù„Ø§Ø­Ù‚Ø§Ù‹
    runtime.player.maxDX = CFG.maxDX;
    runtime.player.jumpV = CFG.jumpV;
    
    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ·Ø¨ÙŠÙ‚ Scaling Ù„Ø¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    applyScaling(state.level); 
    
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¯Ø±ÙˆØ¹
    const maxShields = SHOP_MAP.shieldCapacity.initial + (state.upgrades.shieldCapacity * SHOP_MAP.shieldCapacity.inc);
    state.shield = Math.min(state.shield, maxShields); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¯Ø±ÙˆØ¹ Ø§Ù„Ù…Ø­Ù…ÙˆÙ„Ø©
}

function buyUpgrade(itemId){
    const item = SHOP_MAP[itemId];
    if (state.upgrades[itemId] >= item.max) return false; // ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰
    const currentCost = item.cost + state.upgrades[itemId] * 5; // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªÙƒÙ„ÙØ©
    if (state.coins < currentCost) return false; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¹Ù…Ù„Ø§Øª ÙƒØ§ÙÙŠØ©

    state.coins -= currentCost;
    state.upgrades[itemId]++;
    SFX.purchase();
    applyUpgrades(); // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ© ÙÙˆØ±Ø§Ù‹
    saveProgress();
    updateHUD();
    showShop(); // Ø¥Ø¹Ø§Ø¯Ø© ÙØªØ­ Ø§Ù„Ù…ØªØ¬Ø±
    return true;
}

function showShop(){
    // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù…ØªØ¬Ø±
    state.scene = 'shop';
    
    let shopHTML = `<p>${T('shop_desc')}</p><div class="shop-grid">`;
    
    SHOP_ITEMS.forEach(item => {
        const level = state.upgrades[item.id];
        const maxed = level >= item.max;
        const currentCost = item.cost + level * 5;
        const title = lang === 'ar' ? item.title_ar : item.title_en;
        const desc = lang === 'ar' ? item.desc_ar : item.title_en; // Ø§Ø³ØªØ®Ø¯Ø§Ù… desc_en Ù„Ù„ÙˆØµÙ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ desc_ar
        
        shopHTML += `
            <div class="shop-item">
                <h4>${title} (${lang==='ar'?'Ø§Ù„Ù…Ø±ØªØ¨Ø©':'Level'} ${level}/${item.max})</h4>
                <p>${desc}</p>
                <span class="shop-cost">${maxed ? (lang==='ar'?'Ø§Ù„Ø£Ù‚ØµÙ‰':'Maxed') : `ğŸ’° ${currentCost}`}</span>
                <button class="btn ${maxed ? 'ghost' : 'primary'}" 
                        ${maxed || state.coins < currentCost ? 'disabled' : ''}
                        onclick="buyUpgrade('${item.id}')">
                    ${maxed ? (lang==='ar'?'Ø§Ù„Ø£Ù‚ØµÙ‰':'Max') : (lang==='ar'?'Ø´Ø±Ø§Ø¡':'Buy')}
                </button>
            </div>
        `;
    });
    
    shopHTML += '</div>';

    showOverlay(T('shop_title'), shopHTML, [
        {label: T('resume') + ' â–¶', primary: true, on: ()=>{ hideOverlay(); state.scene='playing'; }}
    ]);
}


/* ================ LEVEL GENERATION: 10 BASIC LEVELS ================= */

function makeBasicLevel(levelIndex) {
    // ØªÙ… ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ù„ØªØ¹Ù…Ù„ Ø¨Ø§Ù„ØªØ³Ù„Ø³Ù„ 0-9
    const H=20, W=120 + levelIndex*10; // Ø²ÙŠØ§Ø¯Ø© Ø·ÙˆÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„
    const map=Array.from({length:H},()=>Array(W).fill(TILE.EMPTY));
    const baseY=H-3;
    const moving = [];
    const enemies = [];
    const coins = []; 
    
    // 1. ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªØ¶Ø§Ø±ÙŠØ³ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    for(let x=0;x<W;x++){
        let y = baseY;
        
        // ØªØ¶Ø§Ø±ÙŠØ³ Ù…ØªØºÙŠØ±Ø© (Ù…Ù†Ø­Ø¯Ø±Ø§Øª ÙˆØ­ÙØ± Ø¨Ø³ÙŠØ·Ø©)
        if(levelIndex >= 2 && x>20 && x<W-20) {
            y += Math.floor(Math.sin(x*0.5/(6+(levelIndex%4)))*2);
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­ÙØ± (Pits)
        if(levelIndex >= 4 && x>60 && x<W-60 && (x%30)===0){
            for(let k=0;k<(levelIndex<7?2:3);k++) {
                if(x+k < W) map[baseY-1][x+k] = TILE.EMPTY; 
            }
        }
        
        for(let py=y;py<H;py++) map[py][x]=TILE.SOLID;
    }
    
    // 2. Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª ÙˆØ§Ù„Ù…Ù†ØµØ§Øª (ØªÙ†ÙˆØ¹ Ø­Ø³Ø¨ Ø±Ù‚Ù… Ø§Ù„Ù…Ø±Ø­Ù„Ø©)
    
    // Ù…Ù†ØµØ§Øª Ø¹Ø§Ø¦Ù…Ø©
    const mpCount = Math.floor(levelIndex/3) + 1;
    for(let m=0;m<mpCount;m++){
        const mx= 30 + m*Math.floor(W/(mpCount+1));
        const yTop= Math.max(5, baseY - 5 - (m%3));
        moving.push({x:mx*CFG.tile,y:yTop*CFG.tile,w:CFG.tile*2,h:CFG.tile/2,t:0,dir:(m%2?1:-1),range:CFG.tile*2});
    }
    
    // ØªØ­Ø¯ÙŠØ§Øª Ø§Ù„Ø£Ø´ÙˆØ§Ùƒ ÙˆØ§Ù„Ù†ÙˆØ§Ø¨Ø¶ (Spikes & Springs)
    for(let x=40;x<W-40;x+=20){
        let groundY = map.length;
        for(let py=0;py<H;py++) if(map[py][x]===TILE.SOLID){ groundY=py; break; }
        
        if(levelIndex >= 3 && groundY < H-1){
            if(Math.random()<0.3) map[groundY][x]=TILE.SPIKE; 
        }
        
        if(levelIndex >= 5 && Math.random()<0.2){
            map[groundY-1][x] = TILE.SPRING; 
        }
    }
    
    // 3. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…Ù„Ø§Øª
    for (let x = 10; x < W - 10; x += 6) {
        if(Math.random() < 0.4 || (levelIndex >= 7 && (x%15)===0)){
            let groundY = map.length;
            for(let py=0;py<H;py++) if(map[py][x]===TILE.SOLID){ groundY=py; break; }
            if (groundY < H - 2) {
                coins.push({x: x*CFG.tile + CFG.tile/2, y: (groundY-2)*CFG.tile + CFG.tile/2});
            }
        }
    }

    // 4. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ (ØªÙ†ÙˆØ¹ Ø£ÙƒØ¨Ø± Ø­Ø³Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø±Ø­Ù„Ø©)
    const enemyTypes = [ENEMY.WALKER, ENEMY.TURTLE, ENEMY.FLIER, ENEMY.SHOOTER];
    const maxType = Math.min(3, Math.floor(levelIndex/2)); // Ø²ÙŠØ§Ø¯Ø© Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹
    const enemyCount = 2 + Math.floor(levelIndex*0.8);
    
    for(let i=0;i<enemyCount;i++){
        const bx=30+i*Math.floor((W-60)/enemyCount);
        const ex=Math.min(W-8,bx+10+(levelIndex%10));
        let yTop = map.length;
        for(let y=0;y<H;y++) if(map[y][bx]===TILE.SOLID){ yTop=y; break; }
        
        const type = enemyTypes[Math.min(maxType, Math.floor(Math.random()*(maxType+1)))];

        const base={x:bx*CFG.tile,y:(yTop-1)*CFG.tile,w:28,h:28,minX:bx*CFG.tile,maxX:ex*CFG.tile,dir:(i%2?1:-1)};
        
        if(type===ENEMY.WALKER) enemies.push({...base,type:ENEMY.WALKER});
        else if(type===ENEMY.TURTLE) enemies.push({...base,type:ENEMY.TURTLE});
        else if(type===ENEMY.FLIER) enemies.push({...base,type:ENEMY.FLIER,y:(Math.max(3,yTop-6))*CFG.tile,w:28,h:22});
        else if(type===ENEMY.SHOOTER) enemies.push({...base,type:ENEMY.SHOOTER,cool:Math.random()*CFG.enemy.fireRate});
    }


    // 5. Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§ÙŠØ©
    const sx=3, sy=baseY-4;
    const gx=W-4, gyEnd=baseY;
    for(let y=gyEnd-4;y<=gyEnd-1;y++) if(y>=0) map[y][gx]=TILE.GOAL;

    return {W,H,map,start:{x:sx*CFG.tile,y:Math.max(0,sy)*CFG.tile},enemies,moving, coins};
}

/* ================ LEVEL GENERATION: JSON LEVELS ================= */

const JSON_LEVEL_CACHE = {};
let JSON_LOAD_PROMISE = null;

// ØªÙ… ØªØ­Ø¯ÙŠØ« fetchJsonLevel Ù„Ø¶Ù…Ø§Ù† ØªØ³Ù„Ø³Ù„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø¨Ø¹Ø¯ Ø§Ù„Ù€ 10 Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
function fetchJsonLevel(index) {
    const jsonIndex = (index - CFG.basicLevelCount) % CFG.jsonFiles.length; // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ø§Ù‚ÙŠ Ù„Ø¶Ù…Ø§Ù† ØªØ¯ÙˆÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª
    const fileName = CFG.jsonFiles[jsonIndex];
    
    if (JSON_LEVEL_CACHE[fileName]) {
        return Promise.resolve(JSON_LEVEL_CACHE[fileName]);
    }
    
    if (JSON_LOAD_PROMISE) {
        return JSON_LOAD_PROMISE;
    }

    JSON_LOAD_PROMISE = fetch(fileName)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to load ${fileName}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            data.W = data.map[0].length;
            data.H = data.map.length;
            if(!data.coins) data.coins = []; 
            JSON_LEVEL_CACHE[fileName] = data;
            JSON_LOAD_PROMISE = null;
            return data;
        })
        .catch(error => {
            console.error(error);
            JSON_LOAD_PROMISE = null;
            // Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù€ JSONØŒ Ù†Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø¢Ø®Ø± Ù…Ø±Ø­Ù„Ø© Ø£Ø³Ø§Ø³ÙŠØ©
            return makeBasicLevel(CFG.basicLevelCount - 1); 
        });
        
    return JSON_LOAD_PROMISE;
}


/* On-demand cache & Level Gateway */
const LEVELS = new Proxy({ store: {} }, {
    get(t, k) {
        const i = Number(k);
        if (Number.isNaN(i) || i < 0) return undefined;
        
        // Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (0 Ø¥Ù„Ù‰ 9)
        if (i < CFG.basicLevelCount) {
            if (!t.store[i]) t.store[i] = makeBasicLevel(i);
            return t.store[i];
        }
        
        // Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© (10 ÙÙ…Ø§ ÙÙˆÙ‚)
        // ÙŠØªÙ… Ø·Ù„Ø¨ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
        if (!t.store[i]) {
            t.store[i] = {W: 960/CFG.tile, H: 540/CFG.tile, map:[], enemies:[], moving:[], coins:[], isAsync: true}; 
            fetchJsonLevel(i)
                .then(data => {
                    t.store[i] = data;
                })
                .catch(err => {
                    t.store[i] = makeBasicLevel(CFG.basicLevelCount - 1); 
                });
        }
        
        return t.store[i];
    }
});


/* ================ OVERLAYS ================ */
function showOverlay(title, bodyHTML, buttons){
  hideOverlay();
  const frag=tplOverlay.content.cloneNode(true);
  frag.querySelector('#ovTitle').textContent=title;
  frag.querySelector('#ovBody').innerHTML=bodyHTML;
  frag.querySelector('#ovHint').textContent=T('hint');
  const box=frag.querySelector('#ovButtons');
  (buttons||[]).forEach(b=>{ const el=document.createElement('button'); el.className='btn '+(b.primary?'primary':'ghost'); el.textContent=b.label; el.addEventListener('click',b.on); box.appendChild(el); });
  document.body.appendChild(frag); state.overlayEl=document.getElementById('overlay');
}
function hideOverlay(){ if(state.overlayEl){ state.overlayEl.remove(); state.overlayEl=null; } }
function splashHTML(){ return `
  <div class="splash">
    <div class="splash-head"><canvas class="splash-canvas" id="splashCanvas"></canvas><div class="splash-title">${I18N[lang].title}</div></div>
    <div class="splash-body">${I18N[lang].desc}<div class="hint" style="margin-top:8px">${I18N[lang].drops}</div></div>
  </div>`;}
function renderSplash(){ const c=document.getElementById('splashCanvas'); if(!c) return;
  const r=c.parentElement.getBoundingClientRect(); c.width=r.width|0; c.height=r.height|0; const x=c.getContext('2d');
  x.fillStyle='#0e1422'; x.fillRect(0,0,c.width,c.height);
  x.fillStyle='#ffffffaa'; for(let i=0;i<100;i++) x.fillRect(Math.random()*c.width, Math.random()*c.height*0.6, 2, 2);
  const hill=(y,col)=>{ x.fillStyle=col; for(let i=-1;i<6;i++){ const bx=i*240; x.beginPath(); x.moveTo(bx,y+200); x.lineTo(bx+120,y+40); x.lineTo(bx+240,y+200); x.closePath(); x.fill(); } };
  hill(c.height*0.45,'#17304a'); hill(c.height*0.55,'#1c3a5a'); hill(c.height*0.65,'#204568');
  requestAnimationFrame(renderSplash);
}

/* ================ SCALING & FLOW ================ */
function applyScaling(levelIndex){
  const b=Math.floor(levelIndex/CFG.scaling.bandSize); 
  state.band=b;
  const eMul=Math.pow(CFG.scaling.enemySpeedMul,b), 
        eFire=Math.pow(CFG.scaling.enemyFireRateMul,b), 
        eBullet=Math.pow(CFG.scaling.enemyBulletSpeedMul,b);
  const pSpd=Math.pow(CFG.scaling.playerSpeedMul,b), 
        pJmp=Math.pow(CFG.scaling.playerJumpMul,b);
        const pBul=Math.pow(CFG.scaling.playerBulletSpeedMul,b);
        const upgradeMul = 1 + (state.upgrades.bulletDmg * SHOP_MAP.bulletDmg.inc);


  runtime.enemy.walkerSpeed=CFG.enemy.walkerSpeed*eMul;
  runtime.enemy.turtleSpeed=CFG.enemy.turtleSpeed*eMul;
  runtime.enemy.flierSpeed =CFG.enemy.flierSpeed *eMul;
  runtime.enemy.shooterSpeed=CFG.enemy.shooterSpeed*eMul;
  runtime.enemy.fireRate   =CFG.enemy.fireRate   *eFire;
  runtime.enemy.bulletSpeed=CFG.enemy.bulletSpeed*eBullet;
  // Ø¯Ù…Ø¬ Ø§Ù„Ù€ Scaling Ù…Ø¹ ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨
  runtime.player.maxDX=CFG.maxDX*pSpd;
  runtime.player.jumpV=CFG.jumpV*pJmp;
  runtime.player.bulletSpeed=(CFG.player.bulletSpeed*pBul) * upgradeMul;
}

function resetRun(){ 
  state.hearts=3; 
  state.shield=0; 
  state.coins=0; 
  state.boosts={speed:0,jump:0}; 
  state.upgrades=SHOP_ITEMS.reduce((acc, item) => (acc[item.id] = 0, acc), {}); 
  applyUpgrades(); 
  saveProgress(); 
}

function startMenu(){
  state.scene='menu'; 
  updateHUD();
  const hasSave=loadProgress();
  showOverlay(I18N[lang].title, splashHTML(), [
    {label:I18N[lang].start, primary:true, on:()=>{ hideOverlay(); resetRun(); startLevel(0,true); }},
   ...(has?[{label:I18N[lang].cont, on:()=>{ hideOverlay(); startLevel(state.level,true); }}]:[])
  ]);
  setTimeout(renderSplash,0);
}

// ØªØ¹Ø¯ÙŠÙ„ startLevel Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ØªØ³Ù„Ø³Ù„
function startLevel(i,reset=true){
  state.level=Math.max(0, i|0); 
  applyScaling(state.level);
  
  const L=LEVELS[state.level];
  // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ØºÙŠØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (Ø¨Ø¹Ø¯ Ø§Ù„Ù€ 10 Ø§Ù„Ø£ÙˆÙ„Ù‰)
  if (L.isAsync) {
    state.scene='loading';
    updateHUD();
    showOverlay(T('stage',state.level+1), lang==='ar'?'Ø¬Ø§Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø±Ø­Ù„Ø©...':'Loading Stage...', []);
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø¨Ø¹Ø¯ 100 Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©
    setTimeout(() => startLevel(i, reset), 100); 
    return;
  }
  
  hideOverlay();
  currentLevelData = L;
  enemies=JSON.parse(JSON.stringify(L.enemies)); 
  enemies.forEach(e=>e._dead=false);
  movingPlatforms=JSON.parse(JSON.stringify(L.moving));
  // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø±Ø­Ù„Ø© ÙÙ‚Ø·
  drops=L.coins.map(c => ({...c, w:16, h:16, type:'coin', ttl:9999})); 
  
  eBullets.length=0; pBullets.length=0;
  if(reset) Object.assign(player,{x:L.start.x,y:L.start.y,dx:0,dy:0,on:false,coyote:0,jumpBuf:0,inv:0,facing:1});
  state.camX=player.x+player.w/2 - canvas.width/2;
  state.camY=player.y+player.h/2 - canvas.height/2;
  state.scene='playing'; 
  updateHUD(); 
  saveProgress(); 
  wantFocus();
}

function finishLevel(){
  SFX.win(); 
  saveProgress();
  state.level++; 
  setTimeout(()=>{ startLevel(state.level, true); }, 1000); 
}

function gameOver(){
  SFX.hit();
  const lvl=state.level;
  showOverlay(I18N[lang].lose, '', [
    {label:T('restart')+' â†º', primary:true, on:()=>{ hideOverlay(); state.level=lvl; startLevel(state.level,true); }},
    {label:T('menu')+' âŒ‚', on:()=>{ hideOverlay(); startMenu(); }}
  ]);
  state.scene='menu';
}

function togglePause(){
  if(state.scene==='playing'){
    state.scene='pause';
    showOverlay(T('paused'),'',[
      {label:T('resume')+' â–¶', primary:true, on:()=>{ hideOverlay(); state.scene='playing'; }},
      {label:T('shop')+' ğŸ›’', on:()=>{ hideOverlay(); showShop(); }}, 
      {label:T('restart')+' â†º', on:()=>{ hideOverlay(); startLevel(state.level,true); }},
      {label:T('menu')+' âŒ‚', on:()=>{ hideOverlay(); startMenu(); }},
      {label: muted?'ğŸ”Š Music':'ğŸ”‡ Music', on:()=>{ muted=!muted; HUD.btnMusic.textContent=muted?'ğŸ”‡':'ğŸ”Š'; hideOverlay(); togglePause(); }},
      {label:(lang==='ar'?'English':'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©'), on:()=>{ lang=(lang==='ar'?'en':'ar'); document.documentElement.lang=lang; document.documentElement.dir=(lang==='ar'?'rtl':'ltr'); HUD.btnLang.textContent=(lang==='ar'?'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©':'English'); updateHUD(); hideOverlay(); togglePause(); }}
    ]);
  }else if(state.scene==='pause'){ 
    hideOverlay(); 
    state.scene='playing'; 
  }
}

/* ================ DROPS ================= */
function spawnDrop(x,y){
  const r=Math.random(); 
  const type=r<0.25?'heart': r<0.5?'shield': r<0.75?'speed':'jump';
  drops.push({x:x-9,y:y-6,w:18,h:18,type,ttl:5});
}
function updateDrops(dt){
  const maxShields = SHOP_MAP.shieldCapacity.initial + (state.upgrades.shieldCapacity * SHOP_MAP.shieldCapacity.inc);

  for(let i=drops.length-1;i>=0;i--){
    const d=drops[i]; 
    d.ttl-=dt;
    if(rects(player,d)){
      if(d.type==='coin'){ 
          state.coins++;
          SFX.coin();
      }
      else if(d.type==='heart' && state.hearts<CFG.player.maxHearts) state.hearts++;
      else if(d.type==='shield') state.shield=Math.min(maxShields,state.shield+1);
      else if(d.type==='speed') state.boosts.speed=Math.min(5,state.boosts.speed+1);
      else if(d.type==='jump') state.boosts.jump=Math.min(5,state.boosts.jump+1);
      else if(d.type!=='coin') SFX.pick(); 
      
      vibrate(20); 
      updateHUD(); 
      drops.splice(i,1); 
      saveProgress();
    }else if(d.ttl<=0 && d.type!=='coin') drops.splice(i,1); 
  }
}
function drawDrops(){
  drops.forEach(d=>{
    const x=d.x-state.camX,y=d.y-state.camY;
    const g=ctx.createRadialGradient(x+d.w/2,y+d.h/2,2,x+d.w/2,y+d.h/2,18); g.addColorStop(0,'#ffffff88'); g.addColorStop(1,'#ffffff00');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x+d.w/2,y+d.h/2,18,0,Math.PI*2); ctx.fill();
    
    // Ø±Ø³Ù… Ø§Ù„Ø¹Ù…Ù„Ø©
    if (d.type === 'coin') {
        ctx.fillStyle = getCSS('--coin');
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#0008';
        ctx.font = '8px sans-serif';
        ctx.fillText('ğŸ’°', x-5, y+4);

    } else {
        // Ø±Ø³Ù… Ø¨Ø§Ù‚ÙŠ Ø§Ù„ØªØ¹Ø²ÙŠØ²Ø§Øª
        ctx.fillStyle= d.type==='heart'?'#e74c3c': d.type==='shield'?'#3498db': d.type==='speed'?'#f1c40f':'#2ecc71';
        if(d.type==='heart'){ ctx.beginPath(); ctx.moveTo(x+9,y+6); ctx.bezierCurveTo(x+2,y+0,x,y+10,x+9,y+14); ctx.bezierCurveTo(x+18,y+10,x+16,y+0,x+9,y+6); ctx.fill(); }
        else if(d.type==='shield'){ ctx.fillRect(x+4,y+5,10,10); ctx.fillRect(x+6,y+15,6,2); }
        else if(d.type==='speed'){ ctx.fillRect(x+4,y+10,12,4); ctx.fillRect(x+10,y+6,4,4); }
        else { ctx.fillRect(x+7,y+4,4,10); ctx.fillRect(x+4,y+10,10,4); }
    }
  });
}

/* ================ MECHANICS ================ */
function shoot(){
  const t=nowSec(); 
  if(t-state.lastShotAt<CFG.player.shootCooldown) return; 
  state.lastShotAt=t; 
  SFX.shoot();
  const dir=player.facing; 
  // Ø±Ø³Ù… Ø§Ù„Ø±ØµØ§ØµØ© (Ø§Ù„Ø³Ù„Ø§Ø­)
  pBullets.push({
    x: player.x + player.w / 2 + (dir * player.w / 2),
    y: player.y + player.h / 2, 
    w: 12, h: 4, 
    dx: dir * runtime.player.bulletSpeed, 
    dy: 0
  });
}
function defeatEnemy(e){
  if(e._dead) return;
  // Ø§Ø­ØªÙ…Ø§Ù„ Ø³Ù‚ÙˆØ· Ø¹Ù…Ù„Ø© Ø¹Ù†Ø¯ Ù‚ØªÙ„ Ø§Ù„Ø¹Ø¯Ùˆ
  if(Math.random() < 0.6) drops.push({x:e.x+e.w/2, y:e.y, w:16, h:16, type:'coin', ttl:9999}); 
  else spawnDrop(e.x+e.w/2, e.y);
  const proto={minX:e.minX,maxX:e.maxX,y:e.y,w:e.w,h:e.h,type:e.type};
  e._dead=true;
  setTimeout(()=>{ Object.assign(e,{...proto,x:proto.minX,dir:1,_dead:false,cool:Math.random()*runtime.enemy.fireRate}); },3000);
}
function hurtPlayer(){
  if(player.inv>0) return;
  const maxShields = SHOP_MAP.shieldCapacity.initial + (state.upgrades.shieldCapacity * SHOP_MAP.shieldCapacity.inc);
  if(state.shield>0){ 
    state.shield=Math.min(maxShields,state.shield-1); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… Ø§Ù„Ù†Ø²ÙˆÙ„ ØªØ­Øª Ø§Ù„ØµÙØ±
    player.inv=1.0; 
    SFX.hit(); 
    vibrate(40); 
    updateHUD(); 
    saveProgress(); 
    return; 
  }
  state.hearts--; 
  player.inv=1.0; 
  SFX.hit(); 
  vibrate(60); 
  updateHUD(); 
  saveProgress();
  if(state.hearts<=0){ gameOver(); return; }
  const L=currentLevelData; 
  Object.assign(player,{x:L.start.x,y:L.start.y,dx:0,dy:0,on:false});
}

/* ================ PHYSICS ================= */
function tileAt(px,py){
  const L=currentLevelData; 
  if (!L || L.isAsync) return TILE.SOLID; 
  const tx=(px/CFG.tile)|0, ty=(py/CFG.tile)|0;
  if(tx<0||ty<0||tx>=L.W||ty>=L.H) return TILE.SOLID;
  return L.map[ty][tx];
}

function moveAndCollide(ent){
  ent.x+=ent.dx;
  if(ent.dx!==0){
    const s=Math.sign(ent.dx), cx=ent.x+(s>0?ent.w:0);
    const pts=[{x:cx,y:ent.y+2},{x:cx,y:ent.y+ent.h-2}];
    for(const p of pts){
      const t=tileAt(p.x,p.y);
      if(t===TILE.SOLID){
        const tx=(p.x/CFG.tile)|0;
        ent.x=tx*CFG.tile - (s>0?ent.w:-CFG.tile);
        ent.dx=0;
        break;
      }
    }
  }
  ent.y+=ent.dy; ent.on=false;
  const vy=ent.y+(ent.dy>0?ent.h:0),
        pts2=[{x:ent.x+2,y:vy},{x:ent.x+ent.w-2,y:vy}];
  for(const p of pts2){
    const t=tileAt(p.x,p.y);
    if(t===TILE.SOLID||t===TILE.MOVING){
      const ty=(p.y/CFG.tile)|0;
      ent.y=ty*CFG.tile - (ent.dy>0?ent.h:-CFG.tile);
      if(ent.dy>0) ent.on=true;
      ent.dy=0;
      break;
    }
  }
  for(const mp of movingPlatforms){
    const r={x:mp.x,y:mp.y,w:mp.w,h:mp.h},
          feet={x:ent.x+2,y:ent.y+ent.h,w:ent.w-4,h:2};
    if(rects(feet,r)){
      ent.y=mp.y-ent.h;
      ent.on=true;
      ent.x+=(mp.x-(mp._px||mp.x));
    }
    mp._px=mp.x;
  }
}

function interactTiles(){
  const L=currentLevelData; 
  if (!L || L.isAsync) return;
  const feet={x:player.x+player.w/2,y:player.y+player.h-2};
  const t=tileAt(feet.x,feet.y);
  if(t===TILE.SPIKE){ hurtPlayer(); }
  if(t===TILE.SPRING){
    player.dy=-CFG.springV*(1+state.boosts.jump*0.1);
    player.on=false;
    SFX.spring();
  }
  if(t===TILE.WATER){
    state.hearts=0;
    updateHUD();
    saveProgress();
    gameOver();
    return;
  }
  const gx=(L.W-4)*CFG.tile,
        gyTop = groundTopAt(L.map,L.W-4);
  const goalBox={x:gx,y:(gyTop-4)*CFG.tile,w:CFG.tile,h:CFG.tile*4};
  if(rects(player,goalBox)) finishLevel();
}

function groundTopAt(map,x){
  for(let y=0;y<map.length;y++)
    if(map[y][x]===TILE.SOLID) return y;
  return map.length-2;
}

/* ================ UPDATE & DRAW ================ */
let last=performance.now();
function update(dt){
  if(state.scene!=='playing') return;

  const L = currentLevelData;
  if (!L || L.isAsync) return; 

  movingPlatforms.forEach(mp=>{
    mp.t+=dt*mp.dir;
    const off=Math.sin(mp.t)*mp.range;
    mp.x+=(off-(mp._p||0));
    mp._p=off;
  });

  let acc=CFG.moveAcc*(1+state.boosts.speed*0.1),
      maxDX=runtime.player.maxDX, // ØªÙ… Ù†Ù‚Ù„ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù€ Scaling Ù‡Ù†Ø§
      jumpV=runtime.player.jumpV; 
  let ax=0;
  if(keys.left){ ax-=acc; player.facing=-1; }
  if(keys.right){ ax+=acc; player.facing=1; }
  player.dx=clamp(player.dx+ax, -maxDX, maxDX);
  if(player.on && ax===0) player.dx*=CFG.friction;
  player.dy=clamp(player.dy+CFG.gravity, -CFG.maxDY, CFG.maxDY);

  // Ù…Ù†Ø·Ù‚ Coyote Time Ùˆ Jump Buffer
  if(keys.jump) player.jumpBuf=CFG.jumpBuffer;
  else player.jumpBuf=Math.max(0,player.jumpBuf-dt);
  player.coyote = player.on? CFG.coyoteTime : Math.max(0,player.coyote-dt);
  if(player.jumpBuf>0 && player.coyote>0){
    player.dy=-jumpV;
    player.on=false;
    player.coyote=0;
    player.jumpBuf=0;
    SFX.jump();
    vibrate(20);
  }
  // Variable Jump Height
  if(!keys.jump && player.dy<-2) player.dy*=CFG.variableJumpCut;

  moveAndCollide(player);

  const worldFloor=(L.H-2)*CFG.tile;
  if(player.y > worldFloor+8){
    state.hearts=0;
    updateHUD();
    saveProgress();
    gameOver();
    return;
  }

  interactTiles();

  if(state.hasGun && keys.shoot) shoot();

  enemies.forEach(e=>{
    if(e._dead) return;
    const sp = e.type===ENEMY.FLIER?runtime.enemy.flierSpeed :
               e.type===ENEMY.SHOOTER?runtime.enemy.shooterSpeed :
               e.type===ENEMY.TURTLE?runtime.enemy.turtleSpeed :
               runtime.enemy.walkerSpeed;
    e.x += e.dir * sp * dt * 60;
    if(e.x<e.minX){ e.x=e.minX; e.dir=1; }
    if(e.x+e.w>e.maxX){ e.x=e.maxX-e.w; e.dir=-1; }
    if(e.type===ENEMY.SHOOTER){
      e.cool=(e.cool||0)-dt;
      if(e.cool<=0){
        e.cool=runtime.enemy.fireRate;
        const dir=(player.x<e.x?-1:1);
        eBullets.push({x:e.x+(dir>0?e.w:0),y:e.y+10,w:10,h:10,dx:dir*runtime.enemy.bulletSpeed,dy:0});
      }
    }
    if(player.inv<=0 && rects(player,e)){
      const stomp = player.dy>0 && (player.y+player.h-e.y)<14;
      if(stomp && (e.type===ENEMY.WALKER||e.type===ENEMY.TURTLE)){
        player.dy=-(runtime.player.jumpV*0.8);
        SFX.hit();
        defeatEnemy(e);
      } else {
        hurtPlayer();
      }
    }
  });

  eBullets.forEach(b=>{ b.x+=b.dx; b.y+=b.dy; });
  eBullets=eBullets.filter(b=>{
    if(rects(player,b)){ hurtPlayer(); return false; }
    return onScreen(b,L);
  });
  pBullets.forEach(b=>{ b.x+=b.dx; b.y+=b.dy; });
  pBullets=pBullets.filter(b=>{
    let alive=true;
    for(const e of enemies){
      if(e._dead) continue;
      if(rects(b,{x:e.x,y:e.y,w:e.w,h:e.h})){
        SFX.hit();
        defeatEnemy(e);
        alive=false;
        break;
      }
    }
    return alive && onScreen(b,L);
  });

  updateDrops(dt);

  const targetX=clamp(player.x+player.w/2 - canvas.width/2, 0, L.W*CFG.tile - canvas.width);
  const targetY=clamp(player.y+player.h/2 - canvas.height*0.6, 0, L.H*CFG.tile-canvas.height);
  state.camX=lerp(state.camX,targetX,CFG.cameraLerp);
  state.camY=lerp(state.camY,targetY,CFG.cameraLerp);

  if(player.inv>0) player.inv=Math.max(0,player.inv-dt);
}
function onScreen(b,L){ return b.x>-64 && b.x<L.W*CFG.tile+64 && b.y>-64 && b.y<L.H*CFG.tile+64; }

function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
function drawParallax(offset, baseY, color){
  ctx.fillStyle=color; for(let i=-1;i<6;i++){ const x=((i*240-(offset%240))|0);
    ctx.beginPath(); ctx.moveTo(x,baseY+120); ctx.lineTo(x+120,baseY+40); ctx.lineTo(x+240,baseY+200); ctx.closePath(); ctx.fill();
  }
}
function draw(){
  ctx.fillStyle=getCSS('--sky'); ctx.fillRect(0,0,canvas.width,canvas.height);
  drawParallax(state.camX*0.5, 90-state.camY*0.5, '#b3e5fc');
  drawParallax(state.camX*0.8, 50-state.camY*0.8, '#d0f0ff');
  
  const L = currentLevelData;
  if (state.scene === 'playing' && L && !L.isAsync) {
    const T=CFG.tile; const sx=(state.camX/T)|0, ex=Math.ceil((state.camX+canvas.width)/T);
    for(let y=0;y<L.H;y++){
      for(let x=sx;x<Math.min(ex,L.W);x++){
        const t=L.map[y][x], px=x*T-state.camX, py=y*T-state.camY;
        if(t===TILE.SOLID){ ctx.fillStyle=getCSS('--ground'); ctx.fillRect(px,py,T,T); ctx.fillStyle=getCSS('--ground-top'); ctx.fillRect(px,py,T,6); }
        else if(t===TILE.SPIKE){ ctx.fillStyle=getCSS('--spike'); ctx.beginPath(); ctx.moveTo(px,py+T); ctx.lineTo(px+T/2,py); ctx.lineTo(px+T,py+T); ctx.closePath(); ctx.fill(); }
        else if(t===TILE.SPRING){ ctx.fillStyle=getCSS('--spring'); ctx.fillRect(px+6,py+T-10,T-12,10); ctx.fillStyle='#85c1e9'; ctx.fillRect(px+6,py+T-16,T-12,6); }
        else if(t===TILE.WATER){ ctx.fillStyle=getCSS('--water'); ctx.fillRect(px,py,T,T); ctx.fillStyle='#ffffff22'; ctx.fillRect(px,py+T-6,T,6); }
        else if(t===TILE.GOAL){ ctx.fillStyle='#fff'; ctx.fillRect(px+T/2-2,py,4,T*4); ctx.fillStyle=getCSS('--goal'); ctx.beginPath(); ctx.moveTo(px+T/2+2,py+6); ctx.lineTo(px+T/2+22,py+16); ctx.lineTo(px+T/2+2,py+26); ctx.closePath(); ctx.fill(); }
      }
    }
  }

  movingPlatforms.forEach(mp=>{ const x=mp.x-state.camX,y=mp.y-state.camY; ctx.fillStyle='#bdc3c7'; ctx.fillRect(x,y,mp.w,mp.h); ctx.fillStyle='#95a5a6'; ctx.fillRect(x,y,mp.w,4); });
  enemies.forEach(e=>{
    if(e._dead) return; const x=e.x-state.camX,y=e.y-state.camY;
    if(e.type===ENEMY.WALKER) ctx.fillStyle=getCSS('--enemy');
    else if(e.type===ENEMY.TURTLE) ctx.fillStyle=getCSS('--turtle');
    else if(e.type===ENEMY.FLIER) ctx.fillStyle=getCSS('--flier');
    else ctx.fillStyle=getCSS('--shooter');
    ctx.fillRect(x,y,e.w,e.h); ctx.fillStyle='#000'; ctx.fillRect(x+6,y+8,4,4); ctx.fillRect(x+e.w-10,y+8,4,4);
  });
  ctx.fillStyle='#f39c12'; eBullets.forEach(b=> ctx.fillRect(b.x-state.camX,b.y-state.camY,b.w,b.h));
  // Ø±Ø³Ù… Ø±ØµØ§Øµ Ø§Ù„Ù„Ø§Ø¹Ø¨ (Ø§Ù„Ø³Ù„Ø§Ø­)
  ctx.fillStyle='#2ecc71'; pBullets.forEach(b=> {
    // Ø±Ø³Ù… Ù…Ø³ØªØ·ÙŠÙ„ ÙŠÙ…Ø«Ù„ Ø§Ù„Ø±ØµØ§ØµØ©
    ctx.fillRect(b.x-state.camX,b.y-state.camY,b.w,b.h);
    // Ø±Ø³Ù… Ù…Ù‚Ø¯Ù…Ø© Ø­Ø§Ø¯Ø© Ù„Ù„Ø±ØµØ§ØµØ© (Ù„ØªØ¨Ø¯Ùˆ ÙƒØ³Ù„Ø§Ø­)
    const tipX = b.x-state.camX + (b.dx > 0 ? b.w : 0);
    const triW = 4, triH = b.h + 2;
    ctx.beginPath();
    ctx.moveTo(tipX, b.y-state.camY - 1);
    ctx.lineTo(tipX + (b.dx > 0 ? triW : -triW), b.y-state.camY + b.h/2);
    ctx.lineTo(tipX, b.y-state.camY + b.h + 1);
    ctx.fill();
  });
  drawDrops();
  
  if (state.scene === 'playing' || state.scene === 'pause') {
      ctx.globalAlpha = player.inv>0? 0.5 + 0.5*Math.sin(performance.now()/40) : 1;
      const px=player.x-state.camX, py=player.y-state.camY;
      ctx.fillStyle=getCSS('--player'); ctx.fillRect(px,py+6,player.w,player.h-6);
      ctx.beginPath(); ctx.arc(px+player.w/2, py+6, player.w/2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#fff'; const eyeY=py+2;
      if(player.facing===1){ ctx.fillRect(px+player.w/2, eyeY, 4,4); ctx.fillRect(px+player.w/2+6, eyeY, 4,4); }
      else { ctx.fillRect(px+player.w/2-10, eyeY, 4,4); ctx.fillRect(px+player.w/2-4, eyeY, 4,4); }
      ctx.fillStyle='#000'; ctx.fillRect(px+player.w/2-4, py+player.h-6, 8,2);
      ctx.globalAlpha=1;
  }
}

/* ================ HUD, LOOP, FIT ================ */
function updateHUD(){
  const heart=(lang==='ar'?'â¤':'â™¥'); HUD.hearts.textContent=heart.repeat(state.hearts);
  HUD.shield.textContent='ğŸ›¡ '+state.shield;
  HUD.coins.textContent='ğŸ’° '+state.coins; 
  HUD.stage.textContent=T('stage',state.level+1);
}
let lastT=performance.now();
function loop(t){ const dt=Math.min(0.05,(t-lastT)/1000); lastT=t; if(state.scene==='playing') update(dt); draw(); requestAnimationFrame(loop); }
function fit(){ const s=Math.min(innerWidth/CFG.viewW, innerHeight/CFG.viewH); canvas.style.width=Math.max(320,(CFG.viewW*s)|0)+'px'; canvas.style.height=Math.max(240,(CFG.viewH*s)|0)+'px'; }
addEventListener('resize',fit);

/* ================ INIT ================ */
function init(){
  const has=loadProgress();
  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø© Ù‚Ø¨Ù„ Ø¨Ø¯Ø¡ Ø£ÙŠ Ø´ÙŠØ¡
  applyUpgrades(); 
  document.documentElement.lang=lang; 
  document.documentElement.dir=(lang==='ar'?'rtl':'ltr'); 
  HUD.btnLang.textContent=(lang==='ar'?'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©':'English'); 

  showOverlay(I18N[lang].title, splashHTML(), [
    {label:I18N[lang].start, primary:true, on:()=>{ hideOverlay(); resetRun(); startLevel(0,true); }},
   ...(has?[{label:I18N[lang].cont, on:()=>{ hideOverlay(); startLevel(state.level,true); }}]:[])
  ]);
  setTimeout(renderSplash,0);
}

// Ø¥Ø¶Ø§ÙØ© ÙˆØ¸ÙŠÙØ© buyUpgrade Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ
window.buyUpgrade = buyUpgrade;

fit();
init();
requestAnimationFrame(t=>{ lastT=t; loop(t); });

})();
</script>
</body>
</html>

