<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ليدو - Ludo</title>
    <style>
        /* الخط الرئيسي للواجهة باللغة العربية */
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');

        body {
            font-family: 'Cairo', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        /* حاوية اللعبة الرئيسية */
        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 500px;
            margin: 10px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            background-color: #fff;
            padding: 15px;
        }

        /* واجهة اللوحة القماشية */
        #ludo-board {
            touch-action: none; /* لمنع السحب عند اللعب */
            border-radius: 8px;
            background-color: #ddd;
            margin-bottom: 15px;
            width: 100%; /* اجعل اللوحة مرنة */
            aspect-ratio: 1 / 1; /* حافظ على نسبة 1:1 */
            border: 5px solid #333; /* إضافة حد مرئي */
        }

        /* منطقة التحكم والحالة */
        #controls-status {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 0 10px;
        }

        #status-display {
            background-color: #eef;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            min-height: 40px;
        }

        #dice-area {
            display: flex;
            align-items: center;
            justify-content: space-around;
            gap: 10px;
        }

        #dice-display {
            width: 60px;
            height: 60px;
            border: 3px solid #333;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2em;
            font-weight: bold;
            background-color: #fff;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s ease;
        }

        /* زر رمي النرد */
        .dice-button {
            background-color: #4CAF50; /* أخضر جذاب */
            color: white;
            padding: 15px 25px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px #388e3c;
            transition: all 0.2s;
            flex-grow: 1;
        }

        .dice-button:hover {
            background-color: #5cb85c;
        }

        .dice-button:active {
            background-color: #388e3c;
            box-shadow: 0 2px #388e3c;
            transform: translateY(3px);
        }

        .dice-button:disabled {
            background-color: #ccc;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        /* أزرار الإعدادات/الصوت */
        .setting-button, #mute-button {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #333;
            padding: 5px;
            transition: color 0.2s;
        }

        .setting-button:hover, #mute-button:hover {
            color: #4CAF50;
        }

        /* الواجهات المنبثقة (Modals) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s;
        }

        .modal.active {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-content h2 {
            color: #4CAF50;
            margin-top: 0;
            font-size: 1.8em;
        }

        .modal-content button {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .modal-content .primary-btn {
            background-color: #4CAF50;
            color: white;
        }

        .modal-content .primary-btn:hover {
            background-color: #388e3c;
        }

        .modal-content .secondary-btn {
            background-color: #f0f0f0;
            color: #333;
            margin-right: 10px;
        }

        /* شاشة الإعدادات */
        #setup-screen {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .setup-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 8px;
        }

        .player-setup-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            gap: 10px;
        }

        .player-setup-row label {
            min-width: 50px;
            font-weight: bold;
        }

        .player-setup-row select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            flex-grow: 1;
            font-family: 'Cairo', sans-serif;
            text-align: right;
            direction: rtl;
        }

        .player-setup-row .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-left: 10px;
            border: 1px solid #33333333;
        }

        /* شريط الأدوات العلوي */
        #top-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
        }
        
        /* التلميحات */
        #tooltip-modal {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            max-width: 90%;
            height: auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-size: 0.9em;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: block; /* Overrides visibility: hidden */
            position: absolute;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #tooltip-modal.active {
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <button id="mute-button" title="كتم الصوت/تشغيل الصوت">🔊</button>
        <button id="setting-button" class="setting-button" title="الإعدادات">⚙️</button>
    </div>

    <div id="game-container">
        <canvas id="ludo-board"></canvas>

        <div id="controls-status">
            <div id="status-display">... تهيئة اللعبة ...</div>

            <div id="dice-area">
                <button class="dice-button" id="roll-dice-button" disabled>رمي النرد</button>
                <div id="dice-display">🎲</div>
            </div>
        </div>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2>🎉 تهانينا! 🎉</h2>
            <p id="winner-message" style="font-size: 1.3em; margin: 20px 0;"></p>
            <button class="primary-btn" id="new-game-from-win">بدء لعبة جديدة</button>
            <button class="secondary-btn" id="share-screenshot">مشاركة لقطة</button>
        </div>
    </div>

    <div id="setup-modal" class="modal active">
        <div class="modal-content">
            <h2>إعدادات لعبة ليدو</h2>

            <div id="setup-screen">
                <div class="setup-group">
                    <label for="player-count">عدد اللاعبين:</label>
                    <select id="player-count">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4" selected>4</option>
                    </select>
                </div>

                <div class="setup-group" id="player-config">
                    <p style="font-weight: bold; margin-bottom: 10px;">نوع اللاعبين:</p>
                    </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="primary-btn" id="start-new-game">بدء لعبة جديدة</button>
                <button class="secondary-btn" id="resume-game" style="display: none;">استئناف اللعبة</button>
            </div>
        </div>
    </div>

    <div id="tooltip-modal" class="active">
        اضغط على زر "رمي النرد" لبدء الدور، ثم اضغط على القطعة لتحريكها!
        <button class="secondary-btn" onclick="document.getElementById('tooltip-modal').classList.remove('active');" style="margin-right: 10px; padding: 5px 10px;">إغلاق</button>
    </div>


<script>
    //================================================================================
    // 1. إعدادات الثوابت والألوان والترجمة العربية
    //================================================================================

    const CANVAS = document.getElementById('ludo-board');
    const CTX = CANVAS.getContext('2d');
    const BASE_SIZE = 600; // حجم أساسي للوحة (ستتم مقايسته)

    const PLAYER_COLORS = {
        0: { name: 'الأحمر', color: '#E53935', light: '#FFCDD2' },
        1: { name: 'الأزرق', color: '#1E88E5', light: '#BBDEFB' },
        2: { name: 'الأخضر', color: '#43A047', light: '#C8E6C9' },
        3: { name: 'الأصفر', color: '#FFB300', light: '#FFECB3' }
    };

    const ARABIC_TEXT = {
        ROLL_DICE: 'رمي النرد',
        CURRENT_TURN: 'الدور الحالي: ',
        ROLLED: 'لقد رميت ',
        EXTRA_TURN: 'دور إضافي! 🎲',
        NO_MOVES: 'لا توجد حركات متاحة، ينتقل الدور.',
        HUMAN: 'بشري',
        AI: 'ذكاء اصطناعي',
        EASY: 'سهل',
        MEDIUM: 'متوسط',
        HARD: 'صعب',
        WINNER_IS: 'الفائز هو ',
        GAME_SAVED: 'تم الحفظ التلقائي.',
        PLAYER: 'اللاعب ',
        START_NEW: 'بدء لعبة جديدة',
        RESUME: 'استئناف اللعبة',
    };

    // تمت مراجعة هذه المواقع، لكن الأهم هي الإحداثيات في BOARD_CONFIG
    const SAFE_SPOTS = [1, 9, 14, 22, 27, 35, 40, 48]; // مواضع آمنة (لا يحدث فيها اصطدام)
    const START_SPOTS = [0, 13, 26, 39]; // مواضع البداية الفعلية لكل لاعب (في المسار المشترك)

    // مسار اللوحة (تحديد الإحداثيات بالنسبة لحجم BASE_SIZE) - الإحداثيات من 0.5 إلى 14.5
    const BOARD_CONFIG = {
        // المسار الخارجي المشترك (52 خانة)
        PATH: [
            // player 0 (red) start path (R1-R6) - 0-5
            {x: 6.5, y: 12.5}, {x: 6.5, y: 11.5}, {x: 6.5, y: 10.5}, {x: 6.5, y: 9.5}, {x: 6.5, y: 8.5},
            {x: 5.5, y: 8.5}, {x: 4.5, y: 8.5}, {x: 3.5, y: 8.5}, {x: 2.5, y: 8.5}, {x: 1.5, y: 8.5}, {x: 0.5, y: 8.5}, // 6-11
            // Left turn (R12-R14) - 12-13
            {x: 0.5, y: 7.5},
            {x: 0.5, y: 6.5}, // 13 (Blue Start)
            // player 1 (blue) path (B1-B6) - 14-19
            {x: 1.5, y: 6.5}, {x: 2.5, y: 6.5}, {x: 3.5, y: 6.5}, {x: 4.5, y: 6.5}, {x: 5.5, y: 6.5},
            {x: 6.5, y: 5.5}, {x: 6.5, y: 4.5}, {x: 6.5, y: 3.5}, {x: 6.5, y: 2.5}, {x: 6.5, y: 1.5}, {x: 6.5, y: 0.5}, // 20-25
            // Top turn (B12-B14) - 26-27
            {x: 7.5, y: 0.5},
            {x: 8.5, y: 0.5}, // 27 (Green Start)
            // player 2 (green) path (G1-G6) - 28-33
            {x: 8.5, y: 1.5}, {x: 8.5, y: 2.5}, {x: 8.5, y: 3.5}, {x: 8.5, y: 4.5}, {x: 8.5, y: 5.5},
            {x: 9.5, y: 6.5}, {x: 10.5, y: 6.5}, {x: 11.5, y: 6.5}, {x: 12.5, y: 6.5}, {x: 13.5, y: 6.5}, {x: 14.5, y: 6.5}, // 34-39
            // Right turn (G12-G14) - 40-41
            {x: 14.5, y: 7.5},
            {x: 14.5, y: 8.5}, // 41 (Yellow Start)
            // player 3 (yellow) path (Y1-Y6) - 42-47
            {x: 13.5, y: 8.5}, {x: 12.5, y: 8.5}, {x: 11.5, y: 8.5}, {x: 10.5, y: 8.5}, {x: 9.5, y: 8.5},
            {x: 8.5, y: 9.5}, {x: 8.5, y: 10.5}, {x: 8.5, y: 11.5}, {x: 8.5, y: 12.5}, {x: 8.5, y: 13.5}, {x: 8.5, y: 14.5}, // 48-51
            // Bottom turn (Y12-Y14) - 52-53
            {x: 7.5, y: 14.5},
            {x: 6.5, y: 14.5}, // 53 (End of path for coordinate calculation) - 52 cells total, index 0-51
        ].slice(0, 52), // تأكد من أن المسار 52 خلية فقط (0-51)
        // مواضع البيت (4 لكل لاعب)
        HOME: [
            [{x: 1.5, y: 10.5}, {x: 1.5, y: 12.5}, {x: 3.5, y: 10.5}, {x: 3.5, y: 12.5}], // Red (0)
            [{x: 1.5, y: 1.5}, {x: 1.5, y: 3.5}, {x: 3.5, y: 1.5}, {x: 3.5, y: 3.5}],   // Blue (1)
            [{x: 10.5, y: 1.5}, {x: 10.5, y: 3.5}, {x: 12.5, y: 1.5}, {x: 12.5, y: 3.5}], // Green (2)
            [{x: 10.5, y: 10.5}, {x: 10.5, y: 12.5}, {x: 12.5, y: 10.5}, {x: 12.5, y: 12.5}], // Yellow (3) 
        ],
        // مسارات الأمان النهائية (6 خانات لكل لاعب)
        FINAL_PATH: [
            [{x: 7.5, y: 13.5}, {x: 7.5, y: 12.5}, {x: 7.5, y: 11.5}, {x: 7.5, y: 10.5}, {x: 7.5, y: 9.5}, {x: 7.5, y: 8.5}], // Red (0)
            [{x: 1.5, y: 7.5}, {x: 2.5, y: 7.5}, {x: 3.5, y: 7.5}, {x: 4.5, y: 7.5}, {x: 5.5, y: 7.5}, {x: 6.5, y: 7.5}], // Blue (1)
            [{x: 7.5, y: 1.5}, {x: 7.5, y: 2.5}, {x: 7.5, y: 3.5}, {x: 7.5, y: 4.5}, {x: 7.5, y: 5.5}, {x: 7.5, y: 6.5}], // Green (2)
            [{x: 13.5, y: 7.5}, {x: 12.5, y: 7.5}, {x: 11.5, y: 7.5}, {x: 10.5, y: 7.5}, {x: 9.5, y: 7.5}, {x: 8.5, y: 7.5}], // Yellow (3)
        ],
        // الهدف المركزي
        GOAL: {x: 7.5, y: 7.5}
    };

    // تحويل إحداثيات (0-15) إلى إحداثيات بكسل
    function toPixel(unit) {
        return unit * (CANVAS.width / 15);
    }

    // إحداثيات البداية في المسار المشترك لكل لاعب (مؤشر المسار العالمي 0-51)
    const START_POSITIONS = [0, 13, 26, 39]; // 0: Red, 13: Blue, 26: Green, 39: Yellow

    //================================================================================
    // 2. فئة الصوت (Base64 Audio Generation)
    //================================================================================

    class SoundManager {
        constructor() {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.muted = localStorage.getItem('ludoMuted') === 'true';
            this.buffers = {};
            this.loadSounds();
            document.getElementById('mute-button').textContent = this.muted ? '🔇' : '🔊';
        }

        async loadSounds() {
            // بيانات PCM بسيطة لتمثيل الأصوات (نغمات قصيرة)
            const sounds = {
                DICE: [0.1, 800, 0.05, 1000, 0.05, 600, 0.05, 1200], // متذبذب وقصير
                MOVE: [0.15, 600], // نغمة قصيرة
                CAPTURE: [0.1, 1500, 0.1, 300], // نغمتان حادتان
                WIN: [0.2, 1200, 0.1, 1500, 0.3, 1800], // تتابع نغمات احتفالية
            };

            for (const key in sounds) {
                this.buffers[key] = this.createBuffer(sounds[key]);
            }
        }

        // إنشاء AudioBuffer من بيانات PCM مبسطة (الزمن بالثواني، التردد بالهرتز)
        createBuffer(sequence) {
            const sampleRate = 44100;
            let totalDuration = 0;
            for (let i = 0; i < sequence.length; i += 2) {
                totalDuration += sequence[i];
            }

            const frameCount = sampleRate * totalDuration;
            const buffer = this.audioCtx.createBuffer(1, frameCount, sampleRate);
            const channel = buffer.getChannelData(0);

            let offset = 0;
            for (let i = 0; i < sequence.length; i += 2) {
                const duration = sequence[i];
                const frequency = sequence[i + 1];
                const segmentFrames = Math.floor(sampleRate * duration);

                for (let j = 0; j < segmentFrames; j++) {
                    const time = j / sampleRate;
                    // موجة جيبية بسيطة
                    channel[offset + j] = Math.sin(2 * Math.PI * frequency * time) * 0.5;
                }
                offset += segmentFrames;
            }
            return buffer;
        }

        play(key) {
            if (this.muted || !this.buffers[key]) return;

            const source = this.audioCtx.createBufferSource();
            source.buffer = this.buffers[key];
            source.connect(this.audioCtx.destination);
            source.start();
        }

        toggleMute() {
            this.muted = !this.muted;
            localStorage.setItem('ludoMuted', this.muted);
            document.getElementById('mute-button').textContent = this.muted ? '🔇' : '🔊';
        }
    }


    //================================================================================
    // 3. فئات اللعبة (Token, Player, GameState)
    //================================================================================

    class Token {
        constructor(id, playerId) {
            this.id = id;
            this.playerId = playerId;
            // 0-3: Home, 4-55: Path (4-55), 56-61: Final Path (56-61), 62: Goal
            this.position = this.id; // يبدأ في البيت (0, 1, 2, 3)
            this.targetX = 0; // للتحريك السلس
            this.targetY = 0;
            this.isMoving = false;
            this.currentX = 0; // تم إضافته للحركة السلسة
            this.currentY = 0;
        }

        // تحديد موقع الخلية بالبكسل
        getCoords() {
            const playerIdx = this.playerId;
            let coords;

            if (this.position < 4) { // في البيت (0, 1, 2, 3)
                coords = BOARD_CONFIG.HOME[playerIdx][this.position];
            } else if (this.position < 56) { // في المسار المشترك (المواضع 4 إلى 55)
                // 4 هي نقطة الخروج من البيت (بداية حساب الخطوات)
                const playerStartIdx = START_POSITIONS[playerIdx]; // 0, 13, 26, 39
                const stepsFromStart = this.position - 4;
                const pathIndex = (playerStartIdx + stepsFromStart) % 52; // المسار المشترك (0-51)
                coords = BOARD_CONFIG.PATH[pathIndex];
            } else if (this.position < 62) { // في مسار الأمان الداخلي (56 إلى 61)
                const finalPathIndex = this.position - 56;
                coords = BOARD_CONFIG.FINAL_PATH[playerIdx][finalPathIndex];
            } else { // في الهدف (62)
                coords = BOARD_CONFIG.GOAL;
            }

            return { x: toPixel(coords.x), y: toPixel(coords.y) };
        }
    }

    class Player {
        constructor(id, type, aiLevel = 'EASY') {
            this.id = id;
            this.color = PLAYER_COLORS[id].color;
            this.name = ARABIC_TEXT.PLAYER + (id + 1) + ' (' + PLAYER_COLORS[id].name + ')';
            this.type = type; // 'HUMAN' or 'AI'
            this.aiLevel = aiLevel; // 'EASY', 'MEDIUM', 'HARD'
            this.tokens = [new Token(0, id), new Token(1, id), new Token(2, id), new Token(3, id)];
        }
    }

    class LudoGame {
        constructor() {
            this.players = [];
            this.currentPlayerIdx = 0;
            this.diceValue = 0;
            this.hasExtraTurn = false;
            this.sixStreak = 0;
            this.isRolling = false;
            this.isAnimating = false;
            this.winner = null;
            this.activePlayers = []; // اللاعبون المشاركون
            this.validMoves = {}; // {tokenId: targetPosition}
            this.selectedToken = null;
            this.sm = new SoundManager();
        }

        // تهيئة اللعبة باللاعبين المختارين
        setupGame(playerConfigs) {
            this.players = [];
            this.activePlayers = [];
            this.currentPlayerIdx = 0;
            this.sixStreak = 0;
            this.winner = null;

            playerConfigs.forEach((config, id) => {
                const player = new Player(id, config.type, config.aiLevel);
                this.players.push(player);
                this.activePlayers.push(id);
                // إعادة القطع إلى البيت
                player.tokens.forEach((token, i) => token.position = i);
            });
            this.updateStatus(ARABIC_TEXT.START_NEW);
            this.diceValue = 0; 
            this.nextTurn();
            this.saveGame();
            this.renderer.render(); // تأكد من الرسم بعد التهيئة
        }

        // تحميل حالة اللعبة من localStorage
        loadGame(state) {
            this.activePlayers = state.activePlayers;
            this.players = state.players.map(pState => {
                const player = new Player(pState.id, pState.type, pState.aiLevel);
                player.tokens = pState.tokens.map(tState => {
                    const token = new Token(tState.id, tState.playerId);
                    token.position = tState.position;
                    return token;
                });
                return player;
            });
            this.currentPlayerIdx = state.currentPlayerIdx;
            this.diceValue = state.diceValue;
            this.sixStreak = state.sixStreak || 0;
            this.winner = state.winner;
            this.hasExtraTurn = state.hasExtraTurn || false;
            this.updateStatus(ARABIC_TEXT.GAME_SAVED);

            // استئناف الحركة إذا كان دور AI
            if (this.isAIPlayer(this.currentPlayerIdx) && !this.winner) {
                this.handleAI();
            } else if (!this.winner) {
                // إذا كان هناك قيمة نرد محفوظة، قم بتحديث الحركات الممكنة
                if (this.diceValue !== 0) {
                     this.validMoves = this.getValidMoves(this.diceValue);
                }
                this.updateRollButton();
                this.renderer.highlightValidMoves(this.validMoves);
            }
        }

        saveGame() {
            const state = {
                players: this.players.map(p => ({
                    id: p.id,
                    type: p.type,
                    aiLevel: p.aiLevel,
                    tokens: p.tokens.map(t => ({
                        id: t.id,
                        playerId: t.playerId,
                        position: t.position
                    }))
                })),
                currentPlayerIdx: this.currentPlayerIdx,
                diceValue: this.diceValue,
                sixStreak: this.sixStreak,
                hasExtraTurn: this.hasExtraTurn,
                activePlayers: this.activePlayers,
                winner: this.winner
            };
            localStorage.setItem('ludoState', JSON.stringify(state));
            document.getElementById('resume-game').style.display = localStorage.getItem('ludoState') ? 'inline-block' : 'none';
        }

        // الانتقال إلى اللاعب التالي
        nextPlayer() {
            let nextIndex = (this.activePlayers.indexOf(this.currentPlayerIdx) + 1) % this.activePlayers.length;
            this.currentPlayerIdx = this.activePlayers[nextIndex];
            this.sixStreak = 0;
            this.hasExtraTurn = false;
        }

        // بدء الدور التالي
        nextTurn() {
            if (this.winner) {
                this.showWinModal(this.winner);
                return;
            }

            // لا ننتقل للاعب التالي إذا كان لديه دور إضافي (6)
            if (!this.hasExtraTurn || this.diceValue === 0) {
                this.nextPlayer();
            }
            
            this.diceValue = 0;
            this.renderer.highlightValidMoves({});
            this.selectedToken = null;
            this.updateRollButton();
            this.renderer.drawDiceValue(this.diceValue); // تصفير النرد في الواجهة

            if (this.isAIPlayer(this.currentPlayerIdx)) {
                this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name);
                setTimeout(() => this.rollDice(), 1000);
            } else {
                this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLL_DICE);
            }
        }

        isAIPlayer(id) {
            // تحقق من وجود اللاعب في المصفوفة قبل الوصول إلى الخاصية
            if (!this.players[id]) return false; 
            return this.players[id].type === 'AI';
        }

        // رمي النرد
        rollDice() {
            if (this.isRolling || this.isAnimating || this.diceValue !== 0) return;

            this.sm.play('DICE');
            this.isRolling = true;
            document.getElementById('roll-dice-button').disabled = true;

            let rollCount = 0;
            const maxRolls = 15;
            const rollInterval = setInterval(() => {
                rollCount++;
                this.diceValue = Math.floor(Math.random() * 6) + 1;
                this.renderer.drawDiceValue(this.diceValue); // تحديث عرض النرد

                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    this.isRolling = false;
                    this.afterDiceRoll();
                }
            }, 80);
        }

        // ما بعد رمي النرد
        afterDiceRoll() {
            this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLLED + this.diceValue);

            const isSix = this.diceValue === 6;

            if (isSix) {
                this.sixStreak++;
                if (this.sixStreak === 3) {
                    this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - 3 ستات متتالية، فقدان الدور!');
                    setTimeout(() => {
                        this.sixStreak = 0;
                        this.hasExtraTurn = false; 
                        this.diceValue = 0; 
                        this.nextTurn();
                    }, 1500);
                    return;
                } else {
                    this.hasExtraTurn = true;
                    this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLLED + this.diceValue + ' - ' + ARABIC_TEXT.EXTRA_TURN);
                }
            } else {
                this.hasExtraTurn = false;
                this.sixStreak = 0;
            }

            this.validMoves = this.getValidMoves(this.diceValue);
            this.renderer.highlightValidMoves(this.validMoves);

            if (Object.keys(this.validMoves).length === 0) {
                // لا توجد حركات صالحة
                this.updateStatus(ARABIC_TEXT.NO_MOVES);
                this.diceValue = 0; // تم استخدام النرد حتى لو لم يكن هناك حركة
                setTimeout(() => this.nextTurn(), 1500);
            } else if (this.isAIPlayer(this.currentPlayerIdx)) {
                this.handleAI();
            } else {
                this.updateRollButton();
            }
        }

        // معالجة دور الذكاء الاصطناعي
        handleAI() {
            const ai = new AI(this);
            const player = this.players[this.currentPlayerIdx];
            const bestMove = ai.chooseBestMove(player.aiLevel, this.diceValue, this.validMoves);

            if (bestMove) {
                const token = player.tokens.find(t => t.id === bestMove.tokenId);
                setTimeout(() => this.moveToken(token, bestMove.targetPosition), 1500);
            } else {
                // لا توجد حركات متاحة لـ AI (تم التعامل معها بالفعل في afterDiceRoll)
                setTimeout(() => this.nextTurn(), 1500);
            }
        }

        // جلب الحركات الصالحة لجميع القطع
        getValidMoves(dice) {
            const validMoves = {};
            const player = this.players[this.currentPlayerIdx];

            if (dice === 0) return {};

            player.tokens.forEach(token => {
                let targetPos = -1;

                if (token.position < 4) { // في البيت (0, 1, 2, 3)
                    if (dice === 6) {
                        targetPos = 4; // الخانة 4 تمثل نقطة الخروج من البيت
                    }
                } else if (token.position < 56) { // في المسار المشترك (4 إلى 55)
                    // 55 هي آخر خانة قبل الدخول إلى مسار الأمان (56)
                    
                    const stepsToFinalPath = 56 - token.position; // 56 هو أول خانة في مسار الأمان
                    
                    if (dice < stepsToFinalPath) {
                        targetPos = token.position + dice;
                    } else if (dice >= stepsToFinalPath) {
                        const finalPathIndex = dice - stepsToFinalPath;
                        if (finalPathIndex <= 6) { // 6 خانات في مسار الأمان + الهدف
                            targetPos = 56 + finalPathIndex; // 56 إلى 62
                        }
                    }
                } else if (token.position >= 56 && token.position < 62) { // في مسار الأمان الداخلي (56 إلى 61)
                    targetPos = token.position + dice;

                    if (targetPos > 62) {
                         targetPos = -1; // لا يمكن تجاوز الهدف (62)
                    }
                }
                
                // التأكد من أن الهدف ليس تجاوزاً (لا يمكن الحركة من الهدف)
                if (token.position === 62) {
                    targetPos = -1;
                }

                if (targetPos !== -1) {
                    validMoves[token.id] = targetPos;
                }
            });
            return validMoves;
        }

        // تنفيذ حركة القطعة
        moveToken(token, targetPosition) {
            if (this.isAnimating) return;

            // بدء الحركة السلسة
            this.isAnimating = true;
            this.renderer.highlightValidMoves({}); // إزالة التظليل عند بدء الحركة
            
            // تحديث حالة النرد للحظة الحركة لمنع النقر
            this.updateRollButton(); 

            this.renderer.startTokenAnimation(token, targetPosition, () => {
                this.isAnimating = false;
                this.sm.play('MOVE');

                // تحقق من الاصطدام بعد وصول القطعة (فقط في المسار المشترك 4-55)
                const oldPosition = token.position;
                token.position = targetPosition; // تحديث الموضع قبل التحقق من الاصطدام
                
                if (targetPosition >= 4 && targetPosition < 56) {
                    this.checkCapture(token, targetPosition);
                }

                this.saveGame();

                // تحقق من الفوز
                this.checkWin(token.playerId);

                // الانتقال إلى الدور التالي (مع مراعاة الدور الإضافي)
                this.diceValue = 0; // تم استخدام النرد
                this.nextTurn();
            });
        }

        // التحقق من الاصطدام
        checkCapture(movingToken, targetPosition) {
            const pathIndex = this.convertToGlobalPathIndex(movingToken.playerId, targetPosition);
            const isSafeSpot = this.isGlobalSafeSpot(pathIndex);

            if (isSafeSpot) return;

            this.players.forEach(player => {
                if (player.id !== movingToken.playerId) {
                    player.tokens.forEach(opponentToken => {
                        // لا يمكن ضرب قطعة في البيت أو مسار الأمان
                        if (opponentToken.position < 4 || opponentToken.position >= 56) return;
                        
                        // حساب موضع الخصم في المسار المشترك
                        const opponentPathPos = this.convertToGlobalPathIndex(opponentToken.playerId, opponentToken.position);

                        if (pathIndex === opponentPathPos) {
                            // اصطدام! إعادة القطعة إلى البيت (الموضع 0-3)
                            opponentToken.position = opponentToken.id;
                            this.sm.play('CAPTURE');
                            this.updateStatus(this.players[movingToken.playerId].name + ' ضرب قطعة لـ ' + player.name);
                        }
                    });
                }
            });
        }

        // دالة مساعدة لتحويل موضع القطعة (4-55) إلى مؤشر المسار المشترك (0-51)
        convertToGlobalPathIndex(playerId, position) {
             const playerStartIdx = START_POSITIONS[playerId];
             const stepsFromStart = position - 4;
             return (playerStartIdx + stepsFromStart) % 52;
        }

        // دالة مساعدة لمعرفة هل الخانة آمنة
        isGlobalSafeSpot(pathIndex) {
            return SAFE_SPOTS.includes(pathIndex) || START_SPOTS.includes(pathIndex);
        }

        // التحقق من الفوز
        checkWin(playerId) {
            const player = this.players[playerId];
            const allTokensInGoal = player.tokens.every(token => token.position === 62);
            if (allTokensInGoal) {
                this.winner = playerId;
                this.showWinModal(playerId);
                localStorage.removeItem('ludoState'); // مسح حالة الحفظ
            }
        }

        // تحديث حالة العرض (النصوص)
        updateStatus(message) {
            document.getElementById('status-display').textContent = message;
        }

        // تحديث حالة زر رمي النرد
        updateRollButton() {
            const rollButton = document.getElementById('roll-dice-button');
            const currentPlayer = this.players[this.currentPlayerIdx];

            if (this.winner) {
                rollButton.disabled = true;
                rollButton.textContent = 'انتهت اللعبة';
            } else if (currentPlayer.type === 'AI' || this.isRolling || this.isAnimating) {
                rollButton.disabled = true;
                rollButton.textContent = 'دور الذكاء الاصطناعي...';
            } else if (this.diceValue === 0) {
                rollButton.disabled = false;
                rollButton.textContent = ARABIC_TEXT.ROLL_DICE;
            } else {
                // بعد الرمي ووجود حركات صالحة، يجب اختيار قطعة
                rollButton.disabled = true;
                rollButton.textContent = 'اختر قطعة';
            }
        }

        showWinModal(winnerId) {
            const winnerName = this.players[winnerId].name;
            document.getElementById('winner-message').textContent = ARABIC_TEXT.WINNER_IS + winnerName;
            document.getElementById('win-modal').classList.add('active');
            this.sm.play('WIN');
            this.renderer.render(); // إعادة الرسم الأخيرة
        }

        // تحديد القطعة للنقل
        selectToken(token) {
            if (this.isAIPlayer(this.currentPlayerIdx) || this.isRolling || this.isAnimating || this.diceValue === 0 || this.winner) return;
            if (token.playerId !== this.currentPlayerIdx) return; // قطعة لاعب آخر

            const targetPos = this.validMoves[token.id];

            if (targetPos !== undefined) {
                this.selectedToken = token;
                this.moveToken(token, targetPos);
            }
        }
    }


    //================================================================================
    // 4. فئة الذكاء الاصطناعي (AI)
    //================================================================================

    class AI {
        constructor(game) {
            this.game = game;
            this.playerId = game.currentPlayerIdx;
            this.player = game.players[this.playerId];
            this.opponentTokens = this.getOpponentTokens();
        }

        getOpponentTokens() {
            return this.game.players
                .filter(p => p.id !== this.playerId)
                .flatMap(p => p.tokens)
                .filter(t => t.position >= 4 && t.position < 56);
        }

        // اختيار أفضل حركة بناءً على المستوى
        chooseBestMove(level, diceValue, validMoves) {
            const moves = Object.entries(validMoves).map(([tokenId, targetPosition]) => ({
                tokenId: parseInt(tokenId),
                targetPosition: targetPosition
            }));

            if (moves.length === 0) return null;

            if (level === 'EASY') {
                return this.easyMove(moves, diceValue);
            } else if (level === 'MEDIUM') {
                return this.mediumMove(moves, diceValue);
            } else { // HARD
                return this.hardMove(moves, diceValue);
            }
        }

        // سهل: يدخل بالـ 6، يحرك أول قطعة متاحة (الأقل ID)
        easyMove(moves, diceValue) {
            // الأولوية لرمي 6 للدخول
            if (diceValue === 6) {
                const homeMove = moves.find(m => this.player.tokens.find(t => t.id === m.tokenId).position < 4);
                if (homeMove) return homeMove;
            }
            // اختيار أول حركة متاحة
            return moves[0];
        }

        // متوسط: يفضّل الضرب، يتجنب الخطر، يوزع التقدم
        mediumMove(moves, diceValue) {
            let bestMove = null;
            let maxScore = -Infinity;

            for (const move of moves) {
                const score = this.evaluateMove(move.tokenId, move.targetPosition, diceValue, 'MEDIUM');
                if (score > maxScore) {
                    maxScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        // صعب: تقييم نقاط متوازن (الأولوية للضرب، التقدم الآمن، القطع الأقرب للهدف)
        hardMove(moves, diceValue) {
            let bestMove = null;
            let maxScore = -Infinity;

            for (const move of moves) {
                const score = this.evaluateMove(move.tokenId, move.targetPosition, diceValue, 'HARD');
                if (score > maxScore) {
                    maxScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        // دالة تقييم الحركة
        evaluateMove(tokenId, targetPosition, diceValue, level) {
            let score = 0;
            const token = this.player.tokens.find(t => t.id === tokenId);

            // 1. تقييم الضرب/الاصطدام (Capture)
            const capturedToken = this.isCaptureMove(targetPosition, token.playerId);
            if (capturedToken) {
                score += 100; // قيمة عالية للضرب
            }

            // 2. تقييم الوصول إلى الهدف (Goal)
            if (targetPosition === 62) {
                score += 500; // قيمة عالية للفوز/الوصول
            }

            // 3. تقييم الخروج من البيت
            if (token.position < 4 && targetPosition === 4) {
                score += 50;
            }

            // 4. تقييم التقدم على اللوحة (أقل قيمة إجمالية = أقرب للهدف)
            // مسافة الهدف (62 - targetPosition)
            score += (62 - targetPosition) * -2;

            // 5. تقييم الأمان (Threat Avoidance)
            if (targetPosition >= 4 && targetPosition < 56) {
                const pathIndex = this.convertToGlobalPathIndex(token.playerId, targetPosition);
                const isSafe = this.isGlobalSafeSpot(pathIndex);

                if (!isSafe) {
                    // تحقق من التهديدات القريبة (Threat)
                    const threats = this.getThreats(pathIndex);
                    if (threats.length > 0) {
                        score -= 80; // عقوبة للوقوف في مكان غير آمن مهدد
                    }
                }
            }

            // 6. مكافأة الدخول إلى مسار الأمان الداخلي
            if (targetPosition >= 56 && token.position < 56) {
                 score += 70;
            }

            // 7. تقييم الخطر (فقط للمستوى الصعب)
            if (level === 'HARD') {
                if (targetPosition >= 4 && targetPosition < 56) {
                    const isSafe = this.isGlobalSafeSpot(this.convertToGlobalPathIndex(token.playerId, targetPosition));
                    if (!isSafe) {
                        // هل القطعة معرضة للضرب في الدور التالي للخصم؟ (التحقق من 1-6 خطوات)
                        const nextTurnThreats = this.getFutureThreats(targetPosition);
                        if (nextTurnThreats.length > 0) {
                            score -= 150; // عقوبة أكبر لتجنب التعريض للخطر
                        }
                    }
                }
            }

            return score;
        }

        // تحويل موضع القطعة (4-55) إلى مؤشر المسار المشترك (0-51)
        convertToGlobalPathIndex(playerId, position) {
            const playerStartIdx = START_POSITIONS[playerId];
            const stepsFromStart = position - 4;
            return (playerStartIdx + stepsFromStart) % 52;
        }

        // هل هذه الخانة آمنة؟
        isGlobalSafeSpot(pathIndex) {
            return SAFE_SPOTS.includes(pathIndex) || START_SPOTS.includes(pathIndex);
        }

        // هل هناك قطعة خصم يمكن ضربها في targetPosition؟
        isCaptureMove(targetPosition, movingPlayerId) {
            if (targetPosition < 4 || targetPosition >= 56) return null; // لا يوجد ضرب في البيت أو مسار الأمان

            const pathIndex = this.convertToGlobalPathIndex(movingPlayerId, targetPosition);
            if (this.isGlobalSafeSpot(pathIndex)) return null; // لا يوجد ضرب في الخانات الآمنة

            return this.opponentTokens.find(t => {
                const opponentPathIndex = this.convertToGlobalPathIndex(t.playerId, t.position);
                return pathIndex === opponentPathIndex;
            });
        }

        // جلب التهديدات الحالية (قطع الخصم الواقفة على الخانة)
        getThreats(pathIndex) {
            return this.opponentTokens.filter(t => {
                const opponentPathIndex = this.convertToGlobalPathIndex(t.playerId, t.position);
                return pathIndex === opponentPathIndex;
            });
        }

        // جلب التهديدات المستقبلية: هل يمكن للخصم الوصول إلى targetPosition في دور قادم؟
        getFutureThreats(targetPosition) {
            const targetPathIndex = this.convertToGlobalPathIndex(this.playerId, targetPosition);
            let threats = [];

            for (const opponentToken of this.opponentTokens) {
                const opponentPlayerId = opponentToken.playerId;
                const opponentGlobalPos = this.convertToGlobalPathIndex(opponentPlayerId, opponentToken.position);

                // المسافة التي يحتاجها الخصم للوصول إلى هدفك
                const distance = (targetPathIndex - opponentGlobalPos + 52) % 52; 

                if (distance >= 1 && distance <= 6) {
                    threats.push(opponentToken);
                }
            }
            return threats;
        }
    }


    //================================================================================
    // 5. فئة الرسام (Renderer)
    //================================================================================

    class Renderer {
        constructor(game) {
            this.game = game;
            this.cellSize = 0;
            this.tokenRadius = 0;
            this.highlightedMoves = {};
            this.activeAnimation = null;
            this.resizeCanvas();
            window.addEventListener('resize', this.resizeCanvas.bind(this));
            CANVAS.addEventListener('click', this.handleCanvasClick.bind(this));
            CANVAS.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = CANVAS.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                this.handleClick(x, y);
            });
        }

        resizeCanvas() {
            const containerWidth = document.getElementById('game-container').clientWidth - 30; // 30 = padding
            CANVAS.width = containerWidth;
            CANVAS.height = containerWidth;
            this.cellSize = CANVAS.width / 15;
            this.tokenRadius = this.cellSize * 0.4;
            this.game.renderer = this; // تحديث مرجع اللعبة للوصول لـ this.cellSize
            this.render();
        }

        // رسم اللوحة كاملة
        render() {
            // لا ترسم بدون تهيئة إلا الهيكل الأساسي
            CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
            this.drawBoardStructure();
            if (this.game.players.length) {
                 this.drawTokens();
            }
        }

        drawBoardStructure() {
            const cs = this.cellSize;

            // 1. رسم منطقة الوسط (التي تحتوي على المسارات والهدف)
            CTX.fillStyle = '#f0f0f0';
            CTX.fillRect(6 * cs, 0 * cs, 3 * cs, 15 * cs); // الشريط الأفقي
            CTX.fillRect(0 * cs, 6 * cs, 15 * cs, 3 * cs); // الشريط العمودي

            // 2. رسم مناطق البيوت (Corners)
            for (let i = 0; i < 4; i++) {
                CTX.fillStyle = PLAYER_COLORS[i].light;
                
                // تحديد موقع منطقة البيت 6x6
                const x = (i === 0 || i === 1) ? 0 : 9 * cs;
                const y = (i === 0 || i === 3) ? 9 * cs : 0; 
                
                CTX.fillRect(x, y, 6 * cs, 6 * cs);

                CTX.strokeStyle = '#333';
                CTX.lineWidth = 2;
                CTX.strokeRect(x, y, 6 * cs, 6 * cs); // حدود البيت الخارجية
            }

            // 3. رسم خلايا المسار الخارجي (الحدود والتلوين)
            // نحتاج لرسم كل خلية في المسار الخارجي والداخلي
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    // خلايا المسار (خارج البيوت)
                    const isTrack = (j >= 6 && j <= 8) || (i >= 6 && i <= 8);
                    const isCorner = (i < 6 && j < 6) || (i >= 9 && j < 6) || (i < 6 && j >= 9) || (i >= 9 && j >= 9);
                    
                    if (isTrack && !isCorner) {
                        CTX.strokeStyle = '#333';
                        CTX.lineWidth = 1;
                        CTX.strokeRect(i * cs, j * cs, cs, cs);
                        
                        // تلوين مسارات الأمان بلون اللاعب
                        if (i === 7 && j >= 9 && j <= 13) CTX.fillStyle = PLAYER_COLORS[0].color; // Red Final Path
                        else if (j === 7 && i >= 1 && i <= 5) CTX.fillStyle = PLAYER_COLORS[1].color; // Blue Final Path
                        else if (i === 7 && j >= 1 && j <= 5) CTX.fillStyle = PLAYER_COLORS[2].color; // Green Final Path
                        else if (j === 7 && i >= 9 && i <= 13) CTX.fillStyle = PLAYER_COLORS[3].color; // Yellow Final Path
                        else CTX.fillStyle = '#fff';

                        CTX.fillRect(i * cs, j * cs, cs, cs);
                        CTX.strokeStyle = '#333';
                        CTX.lineWidth = 1;
                        CTX.strokeRect(i * cs, j * cs, cs, cs);
                    }
                }
            }

            // 4. رسم الهدف المركزي (Goal)
            CTX.fillStyle = '#f0f0f0';
            CTX.beginPath();
            // رسم المركز الماسي
            CTX.moveTo(7.5 * cs, 7.5 * cs);
            CTX.lineTo(6 * cs, 6 * cs);
            CTX.lineTo(9 * cs, 6 * cs);
            CTX.lineTo(9 * cs, 9 * cs);
            CTX.lineTo(6 * cs, 9 * cs);
            CTX.closePath();
            CTX.fill();

            // 5. تظليل الخانات الآمنة (بالنجمة)
            CTX.textAlign = 'center';
            CTX.textBaseline = 'middle';
            CTX.font = `${cs * 0.7}px Arial`;

            // مواضع البيوت الداخلية (لعبة الليدو الأصلية ترسم دائرة حول مكان قطعة البداية)
            for (let i = 0; i < 4; i++) {
                const homeCoords = BOARD_CONFIG.HOME[i];
                CTX.strokeStyle = '#333';
                CTX.lineWidth = 1.5;
                homeCoords.forEach(c => {
                    CTX.beginPath();
                    CTX.arc(toPixel(c.x), toPixel(c.y), this.tokenRadius * 1.3, 0, 2 * Math.PI);
                    CTX.stroke();
                });
            }

            // رسم النجوم على الخانات الآمنة وخانات البداية
            SAFE_SPOTS.concat(START_SPOTS).forEach(index => {
                const coords = BOARD_CONFIG.PATH[index];
                
                // تحديد لون خلفية النجمة
                let starColor = '#fff';
                if (START_SPOTS.includes(index)) {
                     const playerIdx = START_SPOTS.indexOf(index);
                     starColor = PLAYER_COLORS[playerIdx].color;
                } else if (index === 1 || index === 14 || index === 27 || index === 40) {
                     const playerIdx = [1, 14, 27, 40].indexOf(index);
                     starColor = PLAYER_COLORS[playerIdx].color;
                }
                
                // إعادة رسم الخلفية للخانة لتكون ملونة بالكامل
                CTX.fillStyle = starColor;
                CTX.fillRect(coords.x * cs - cs / 2, coords.y * cs - cs / 2, cs, cs);
                CTX.strokeStyle = '#333';
                CTX.lineWidth = 1;
                CTX.strokeRect(coords.x * cs - cs / 2, coords.y * cs - cs / 2, cs, cs);


                // رسم علامة الأمان (نجمة)
                CTX.fillStyle = 'white';
                CTX.fillText('★', toPixel(coords.x), toPixel(coords.y) + 2);
            });

            // 6. تظليل الحركات الممكنة
            this.highlightValidMoves(this.highlightedMoves, false); // لا ترسم الهيكل مرة أخرى
        }

        highlightValidMoves(moves, redraw = true) {
            this.highlightedMoves = moves;

            if (redraw) {
                this.render();
            }

            if (Object.keys(moves).length === 0) return;

            const targetPositions = Object.values(moves);
            const cs = this.cellSize;

            // استخدام مجموعة لضمان تظليل الخانة مرة واحدة فقط
            const uniqueTargets = [...new Set(targetPositions)];

            uniqueTargets.forEach(pos => {
                let coords;
                // إنشاء قطعة مؤقتة فقط للحصول على إحداثيات الهدف
                const tokenAtTarget = new Token(0, this.game.currentPlayerIdx);
                tokenAtTarget.position = pos;
                coords = tokenAtTarget.getCoords();

                // رسم دائرة تظليل حول الخانة
                CTX.strokeStyle = 'gold';
                CTX.lineWidth = 4;
                CTX.beginPath();
                // يمكن تظليل الخانة نفسها أو القطعة، نختار الخانة
                CTX.arc(coords.x, coords.y, cs * 0.48, 0, 2 * Math.PI);
                CTX.stroke();
            });
        }

        // رسم القطع
        drawTokens() {
            this.game.players.forEach(player => {
                player.tokens.forEach(token => {
                    let { x, y } = token.getCoords();

                    // استخدام الإحداثيات المتحركة إذا كانت القطعة في حالة حركة
                    if (token.isMoving) {
                        x = token.currentX;
                        y = token.currentY;
                    }

                    // تجميع القطع الواقفة في نفس الخانة لتجنب التداخل
                    // منطق بسيط: إزاحة خفيفة للقطع المشتركة في نفس الموضع
                    let offset = 0;
                    if (token.position >= 4 && token.position < 62) {
                        const tokensAtSameSpot = player.tokens.filter(t => t.position === token.position);
                        if (tokensAtSameSpot.length > 1) {
                            const index = tokensAtSameSpot.indexOf(token);
                            offset = (index - (tokensAtSameSpot.length - 1) / 2) * (this.tokenRadius * 0.5); // إزاحة بسيطة
                        }
                    }


                    CTX.fillStyle = player.color;
                    CTX.strokeStyle = '#333';
                    CTX.lineWidth = 2;

                    // الظل
                    CTX.shadowColor = 'rgba(0,0,0,0.4)';
                    CTX.shadowBlur = 4;
                    CTX.shadowOffsetX = 2;
                    CTX.shadowOffsetY = 2;

                    // جسم القطعة
                    CTX.beginPath();
                    CTX.arc(x + offset, y, this.tokenRadius, 0, 2 * Math.PI);
                    CTX.fill();
                    CTX.stroke();

                    // إزالة الظل للرسم التالي
                    CTX.shadowBlur = 0;
                    CTX.shadowOffsetX = 0;
                    CTX.shadowOffsetY = 0;

                    // رقم القطعة
                    CTX.fillStyle = '#fff';
                    CTX.font = `${this.tokenRadius * 0.9}px Cairo, sans-serif`;
                    CTX.fillText((token.id + 1), x + offset, y + 2);
                });
            });
        }

        // رسم قيمة النرد
        drawDiceValue(value) {
            document.getElementById('dice-display').textContent = value === 0 ? '🎲' : value;
        }

        // بدء حركة القطعة السلسة (Tweening)
        startTokenAnimation(token, targetPosition, callback) {
            token.isMoving = true;
            token.currentX = token.getCoords().x;
            token.currentY = token.getCoords().y;

            const startPos = token.position;
            const path = this.getAnimationPath(token.playerId, startPos, targetPosition);

            if (path.length === 0) {
                token.isMoving = false;
                callback();
                return;
            }

            let pathIndex = 0;
            const animationDuration = 100; // مدة الحركة بين خانتين (بالمللي ثانية)
            let startTime = null;
            let currentPathStep = path[0];

            const step = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;

                if (elapsed < animationDuration) {
                    // حركة سلسة (Tween)
                    const progress = elapsed / animationDuration;
                    token.currentX = currentPathStep.startX + (currentPathStep.endX - currentPathStep.startX) * progress;
                    token.currentY = currentPathStep.startY + (currentPathStep.endY - currentPathStep.startY) * progress;
                } else {
                    // الانتقال إلى الخانة التالية في المسار
                    token.currentX = currentPathStep.endX;
                    token.currentY = currentPathStep.endY;
                    pathIndex++;
                    startTime = timestamp; // إعادة تعيين وقت البدء للحركة التالية

                    if (pathIndex >= path.length) {
                        // نهاية الحركة
                        token.isMoving = false;
                        this.game.isAnimating = false;
                        callback();
                        return;
                    }

                    // البدء في الخطوة التالية
                    currentPathStep = path[pathIndex];
                }

                this.render();
                requestAnimationFrame(step);
            };

            this.game.isAnimating = true;
            requestAnimationFrame(step);
        }

        // حساب مسار الحركة خطوة بخطوة للرسوم المتحركة
        getAnimationPath(playerId, startPos, targetPos) {
            const path = [];
            let currentPos = startPos;

            // مسار الحركة هو خطوة خطوة، لذلك نحتاج إلى إحداثيات كل خانة على طول الطريق
            while (currentPos !== targetPos) {
                let nextPos = currentPos + 1;
                
                // إذا كانت القطعة ستدخل مسار الأمان، فإن النقلة التالية هي 56
                if (currentPos < 56 && nextPos >= 56) nextPos = 56;
                // إذا كانت القطعة وصلت للهدف، يجب أن تتوقف
                if (currentPos >= 62) break;

                const tokenAtCurrent = new Token(0, playerId);
                tokenAtCurrent.position = currentPos;
                const startCoords = tokenAtCurrent.getCoords();

                const tokenAtNext = new Token(0, playerId);
                tokenAtNext.position = nextPos;
                const endCoords = tokenAtNext.getCoords();

                path.push({
                    startX: startCoords.x,
                    startY: startCoords.y,
                    endX: endCoords.x,
                    endY: endCoords.y,
                });

                currentPos = nextPos;
            }
            return path;
        }

        // معالجة النقر على اللوحة
        handleClick(x, y) {
            if (this.game.isRolling || this.game.isAnimating || this.game.winner || this.game.isAIPlayer(this.game.currentPlayerIdx) || this.game.diceValue === 0) return;

            for (const player of this.game.players) {
                for (const token of player.tokens) {
                    const { x: tx, y: ty } = token.getCoords();
                    // استخدام نصف قطر القطعة للتحقق من النقر
                    const distSq = (x - tx) ** 2 + (y - ty) ** 2;

                    if (distSq < this.tokenRadius ** 2) {
                        // تم النقر على هذه القطعة
                        this.game.selectToken(token);
                        return;
                    }
                }
            }
        }

        handleCanvasClick(event) {
            const rect = CANVAS.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            this.handleClick(x, y);
        }
    }


    //================================================================================
    // 6. تهيئة اللعبة وإدارة الأحداث
    //================================================================================

    let game = new LudoGame();
    let renderer = new Renderer(game);
    game.renderer = renderer;

    // تهيئة شاشة الإعدادات
    const playerCountSelect = document.getElementById('player-count');
    const playerConfigDiv = document.getElementById('player-config');

    function updatePlayerConfig() {
        const count = parseInt(playerCountSelect.value);
        playerConfigDiv.innerHTML = '<p style="font-weight: bold; margin-bottom: 10px;">نوع اللاعبين:</p>';

        for (let i = 0; i < 4; i++) {
            const colorName = PLAYER_COLORS[i].name;
            const colorCode = PLAYER_COLORS[i].color;
            const isVisible = i < count;

            const row = document.createElement('div');
            row.className = 'player-setup-row';
            row.style.display = isVisible ? 'flex' : 'none';

            // مؤشر اللون
            const colorIndicator = document.createElement('div');
            colorIndicator.className = 'color-indicator';
            colorIndicator.style.backgroundColor = colorCode;

            // اسم اللاعب
            const label = document.createElement('label');
            label.textContent = colorName;

            // اختيار النوع (بشري/ذكاء اصطناعي)
            const typeSelect = document.createElement('select');
            typeSelect.id = `player-type-${i}`;
            typeSelect.innerHTML = `<option value="HUMAN">${ARABIC_TEXT.HUMAN}</option><option value="AI">${ARABIC_TEXT.AI}</option>`;
            typeSelect.value = i === 0 ? 'HUMAN' : 'AI';

            // اختيار المستوى (يظهر فقط إذا كان AI)
            const levelSelect = document.createElement('select');
            levelSelect.id = `ai-level-${i}`;
            levelSelect.innerHTML = `<option value="EASY">${ARABIC_TEXT.EASY}</option><option value="MEDIUM" selected>${ARABIC_TEXT.MEDIUM}</option><option value="HARD">${ARABIC_TEXT.HARD}</option>`;
            levelSelect.style.display = typeSelect.value === 'AI' ? 'block' : 'none';

            typeSelect.addEventListener('change', () => {
                levelSelect.style.display = typeSelect.value === 'AI' ? 'block' : 'none';
            });

            row.appendChild(colorIndicator);
            row.appendChild(label);
            row.appendChild(typeSelect);
            row.appendChild(levelSelect);
            playerConfigDiv.appendChild(row);
        }
    }

    playerCountSelect.addEventListener('change', updatePlayerConfig);

    // التحقق من حالة الحفظ التلقائي عند التحميل
    window.onload = function() {
        updatePlayerConfig();

        if (localStorage.getItem('ludoState')) {
            document.getElementById('resume-game').style.display = 'inline-block';
            document.getElementById('start-new-game').textContent = ARABIC_TEXT.START_NEW;
        } else {
             document.getElementById('resume-game').style.display = 'none';
             document.getElementById('start-new-game').textContent = ARABIC_TEXT.START_NEW;
        }
        
        // رسم اللوحة حتى لو كانت شاشة الإعدادات مفتوحة
        renderer.render();
    }

    // وظيفة بدء لعبة جديدة (من الإعدادات أو الفوز)
    function startNewGame(resume = false) {
        document.getElementById('setup-modal').classList.remove('active');
        document.getElementById('win-modal').classList.remove('active');
        document.getElementById('tooltip-modal').classList.remove('active'); // إغلاق التلميح

        if (resume) {
            try {
                const state = JSON.parse(localStorage.getItem('ludoState'));
                if (state) {
                    // يجب إعادة إنشاء إعدادات اللاعبين لـ setupGame بشكل صحيح
                    const playerConfigs = state.players.map(p => ({
                        type: p.type,
                        aiLevel: p.aiLevel
                    }));
                    game.setupGame(playerConfigs); // تهيئة اللاعبين (لإعادة إنشاء كائنات Token)
                    game.loadGame(state); // تحميل الحالة
                    renderer.render();
                    return;
                }
            } catch(e) {
                console.error("Failed to load game state:", e);
                localStorage.removeItem('ludoState');
            }
        }

        // بدء جديد
        const count = parseInt(playerCountSelect.value);
        const playerConfigs = [];
        for (let i = 0; i < count; i++) {
            const type = document.getElementById(`player-type-${i}`).value;
            const level = document.getElementById(`ai-level-${i}`).value;
            playerConfigs.push({ type, aiLevel: level });
        }

        game.setupGame(playerConfigs);
    }

    // ربط الأحداث
    document.getElementById('start-new-game').addEventListener('click', () => startNewGame(false));
    document.getElementById('resume-game').addEventListener('click', () => startNewGame(true));
    document.getElementById('roll-dice-button').addEventListener('click', () => game.rollDice());
    document.getElementById('setting-button').addEventListener('click', () => {
        document.getElementById('setup-modal').classList.add('active');
    });
    document.getElementById('mute-button').addEventListener('click', () => game.sm.toggleMute());
    document.getElementById('new-game-from-win').addEventListener('click', () => {
        document.getElementById('win-modal').classList.remove('active');
        document.getElementById('setup-modal').classList.add('active');
    });
    document.getElementById('share-screenshot').addEventListener('click', () => {
        const dataURL = CANVAS.toDataURL('image/png');
        const w = window.open('about:blank', '_blank');
        w.document.write('<img src="' + dataURL + '" style="max-width:100%; height:auto;">');
    });

    // إزالة التلميح بعد بضع ثوانٍ
    setTimeout(() => {
        document.getElementById('tooltip-modal').classList.remove('active');
    }, 5000);

</script>
</body>
</html>

