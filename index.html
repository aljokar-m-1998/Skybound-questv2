<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„ÙŠØ¯Ùˆ - Ludo</title>
    <style>
        /* Ø§Ù„Ø®Ø· Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© */
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');

        body {
            font-family: 'Cairo', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        /* Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© */
        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 500px;
            margin: 10px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            background-color: #fff;
            padding: 15px;
        }

        /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù‚Ù…Ø§Ø´ÙŠØ© */
        #ludo-board {
            touch-action: none; /* Ù„Ù…Ù†Ø¹ Ø§Ù„Ø³Ø­Ø¨ Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø¹Ø¨ */
            border-radius: 8px;
            background-color: #ddd;
            margin-bottom: 15px;
            width: 100%; /* Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù„ÙˆØ­Ø© Ù…Ø±Ù†Ø© */
            aspect-ratio: 1 / 1; /* Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© 1:1 */
            border: 5px solid #333; /* Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ù…Ø±Ø¦ÙŠ */
        }

        /* Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ­ÙƒÙ… ÙˆØ§Ù„Ø­Ø§Ù„Ø© */
        #controls-status {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 0 10px;
        }

        #status-display {
            background-color: #eef;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            min-height: 40px;
        }

        #dice-area {
            display: flex;
            align-items: center;
            justify-content: space-around;
            gap: 10px;
        }

        #dice-display {
            width: 60px;
            height: 60px;
            border: 3px solid #333;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2em;
            font-weight: bold;
            background-color: #fff;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s ease;
        }

        /* Ø²Ø± Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯ */
        .dice-button {
            background-color: #4CAF50; /* Ø£Ø®Ø¶Ø± Ø¬Ø°Ø§Ø¨ */
            color: white;
            padding: 15px 25px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px #388e3c;
            transition: all 0.2s;
            flex-grow: 1;
        }

        .dice-button:hover {
            background-color: #5cb85c;
        }

        .dice-button:active {
            background-color: #388e3c;
            box-shadow: 0 2px #388e3c;
            transform: translateY(3px);
        }

        .dice-button:disabled {
            background-color: #ccc;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª/Ø§Ù„ØµÙˆØª */
        .setting-button, #mute-button {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #333;
            padding: 5px;
            transition: color 0.2s;
        }

        .setting-button:hover, #mute-button:hover {
            color: #4CAF50;
        }

        /* Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© (Modals) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s;
        }

        .modal.active {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-content h2 {
            color: #4CAF50;
            margin-top: 0;
            font-size: 1.8em;
        }

        .modal-content button {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .modal-content .primary-btn {
            background-color: #4CAF50;
            color: white;
        }

        .modal-content .primary-btn:hover {
            background-color: #388e3c;
        }

        .modal-content .secondary-btn {
            background-color: #f0f0f0;
            color: #333;
            margin-right: 10px;
        }

        /* Ø´Ø§Ø´Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª */
        #setup-screen {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .setup-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 8px;
        }

        .player-setup-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            gap: 10px;
        }

        .player-setup-row label {
            min-width: 50px;
            font-weight: bold;
        }

        .player-setup-row select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            flex-grow: 1;
            font-family: 'Cairo', sans-serif;
            text-align: right;
            direction: rtl;
        }

        .player-setup-row .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-left: 10px;
            border: 1px solid #33333333;
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¹Ù„ÙˆÙŠ */
        #top-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
        }
        
        /* Ø§Ù„ØªÙ„Ù…ÙŠØ­Ø§Øª */
        #tooltip-modal {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            max-width: 90%;
            height: auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-size: 0.9em;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: block; /* Overrides visibility: hidden */
            position: absolute;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #tooltip-modal.active {
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <button id="mute-button" title="ÙƒØªÙ… Ø§Ù„ØµÙˆØª/ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª">ğŸ”Š</button>
        <button id="setting-button" class="setting-button" title="Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª">âš™ï¸</button>
    </div>

    <div id="game-container">
        <canvas id="ludo-board"></canvas>

        <div id="controls-status">
            <div id="status-display">... ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ...</div>

            <div id="dice-area">
                <button class="dice-button" id="roll-dice-button" disabled>Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯</button>
                <div id="dice-display">ğŸ²</div>
            </div>
        </div>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2>ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ğŸ‰</h2>
            <p id="winner-message" style="font-size: 1.3em; margin: 20px 0;"></p>
            <button class="primary-btn" id="new-game-from-win">Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            <button class="secondary-btn" id="share-screenshot">Ù…Ø´Ø§Ø±ÙƒØ© Ù„Ù‚Ø·Ø©</button>
        </div>
    </div>

    <div id="setup-modal" class="modal active">
        <div class="modal-content">
            <h2>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ø¹Ø¨Ø© Ù„ÙŠØ¯Ùˆ</h2>

            <div id="setup-screen">
                <div class="setup-group">
                    <label for="player-count">Ø¹Ø¯Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†:</label>
                    <select id="player-count">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4" selected>4</option>
                    </select>
                </div>

                <div class="setup-group" id="player-config">
                    <p style="font-weight: bold; margin-bottom: 10px;">Ù†ÙˆØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†:</p>
                    </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="primary-btn" id="start-new-game">Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
                <button class="secondary-btn" id="resume-game" style="display: none;">Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            </div>
        </div>
    </div>

    <div id="tooltip-modal" class="active">
        Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± "Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯" Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø¯ÙˆØ±ØŒ Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø·Ø¹Ø© Ù„ØªØ­Ø±ÙŠÙƒÙ‡Ø§!
        <button class="secondary-btn" onclick="document.getElementById('tooltip-modal').classList.remove('active');" style="margin-right: 10px; padding: 5px 10px;">Ø¥ØºÙ„Ø§Ù‚</button>
    </div>


<script>
    //================================================================================
    // 1. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø«ÙˆØ§Ø¨Øª ÙˆØ§Ù„Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
    //================================================================================

    const CANVAS = document.getElementById('ludo-board');
    const CTX = CANVAS.getContext('2d');
    const BASE_SIZE = 600; // Ø­Ø¬Ù… Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„ÙˆØ­Ø© (Ø³ØªØªÙ… Ù…Ù‚Ø§ÙŠØ³ØªÙ‡)

    const PLAYER_COLORS = {
        0: { name: 'Ø§Ù„Ø£Ø­Ù…Ø±', color: '#E53935', light: '#FFCDD2' },
        1: { name: 'Ø§Ù„Ø£Ø²Ø±Ù‚', color: '#1E88E5', light: '#BBDEFB' },
        2: { name: 'Ø§Ù„Ø£Ø®Ø¶Ø±', color: '#43A047', light: '#C8E6C9' },
        3: { name: 'Ø§Ù„Ø£ØµÙØ±', color: '#FFB300', light: '#FFECB3' }
    };

    const ARABIC_TEXT = {
        ROLL_DICE: 'Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯',
        CURRENT_TURN: 'Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠ: ',
        ROLLED: 'Ù„Ù‚Ø¯ Ø±Ù…ÙŠØª ',
        EXTRA_TURN: 'Ø¯ÙˆØ± Ø¥Ø¶Ø§ÙÙŠ! ğŸ²',
        NO_MOVES: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ù…ØªØ§Ø­Ø©ØŒ ÙŠÙ†ØªÙ‚Ù„ Ø§Ù„Ø¯ÙˆØ±.',
        HUMAN: 'Ø¨Ø´Ø±ÙŠ',
        AI: 'Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',
        EASY: 'Ø³Ù‡Ù„',
        MEDIUM: 'Ù…ØªÙˆØ³Ø·',
        HARD: 'ØµØ¹Ø¨',
        WINNER_IS: 'Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ ',
        GAME_SAVED: 'ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.',
        PLAYER: 'Ø§Ù„Ù„Ø§Ø¹Ø¨ ',
        START_NEW: 'Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©',
        RESUME: 'Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø©',
    };

    // ØªÙ…Øª Ù…Ø±Ø§Ø¬Ø¹Ø© Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ØŒ Ù„ÙƒÙ† Ø§Ù„Ø£Ù‡Ù… Ù‡ÙŠ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ÙÙŠ BOARD_CONFIG
    const SAFE_SPOTS = [1, 9, 14, 22, 27, 35, 40, 48]; // Ù…ÙˆØ§Ø¶Ø¹ Ø¢Ù…Ù†Ø© (Ù„Ø§ ÙŠØ­Ø¯Ø« ÙÙŠÙ‡Ø§ Ø§ØµØ·Ø¯Ø§Ù…)
    const START_SPOTS = [0, 13, 26, 39]; // Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨ (ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ)

    // Ù…Ø³Ø§Ø± Ø§Ù„Ù„ÙˆØ­Ø© (ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ø­Ø¬Ù… BASE_SIZE) - Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù…Ù† 0.5 Ø¥Ù„Ù‰ 14.5
    const BOARD_CONFIG = {
        // Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ Ø§Ù„Ù…Ø´ØªØ±Ùƒ (52 Ø®Ø§Ù†Ø©)
        PATH: [
            // player 0 (red) start path (R1-R6) - 0-5
            {x: 6.5, y: 12.5}, {x: 6.5, y: 11.5}, {x: 6.5, y: 10.5}, {x: 6.5, y: 9.5}, {x: 6.5, y: 8.5},
            {x: 5.5, y: 8.5}, {x: 4.5, y: 8.5}, {x: 3.5, y: 8.5}, {x: 2.5, y: 8.5}, {x: 1.5, y: 8.5}, {x: 0.5, y: 8.5}, // 6-11
            // Left turn (R12-R14) - 12-13
            {x: 0.5, y: 7.5},
            {x: 0.5, y: 6.5}, // 13 (Blue Start)
            // player 1 (blue) path (B1-B6) - 14-19
            {x: 1.5, y: 6.5}, {x: 2.5, y: 6.5}, {x: 3.5, y: 6.5}, {x: 4.5, y: 6.5}, {x: 5.5, y: 6.5},
            {x: 6.5, y: 5.5}, {x: 6.5, y: 4.5}, {x: 6.5, y: 3.5}, {x: 6.5, y: 2.5}, {x: 6.5, y: 1.5}, {x: 6.5, y: 0.5}, // 20-25
            // Top turn (B12-B14) - 26-27
            {x: 7.5, y: 0.5},
            {x: 8.5, y: 0.5}, // 27 (Green Start)
            // player 2 (green) path (G1-G6) - 28-33
            {x: 8.5, y: 1.5}, {x: 8.5, y: 2.5}, {x: 8.5, y: 3.5}, {x: 8.5, y: 4.5}, {x: 8.5, y: 5.5},
            {x: 9.5, y: 6.5}, {x: 10.5, y: 6.5}, {x: 11.5, y: 6.5}, {x: 12.5, y: 6.5}, {x: 13.5, y: 6.5}, {x: 14.5, y: 6.5}, // 34-39
            // Right turn (G12-G14) - 40-41
            {x: 14.5, y: 7.5},
            {x: 14.5, y: 8.5}, // 41 (Yellow Start)
            // player 3 (yellow) path (Y1-Y6) - 42-47
            {x: 13.5, y: 8.5}, {x: 12.5, y: 8.5}, {x: 11.5, y: 8.5}, {x: 10.5, y: 8.5}, {x: 9.5, y: 8.5},
            {x: 8.5, y: 9.5}, {x: 8.5, y: 10.5}, {x: 8.5, y: 11.5}, {x: 8.5, y: 12.5}, {x: 8.5, y: 13.5}, {x: 8.5, y: 14.5}, // 48-51
            // Bottom turn (Y12-Y14) - 52-53
            {x: 7.5, y: 14.5},
            {x: 6.5, y: 14.5}, // 53 (End of path for coordinate calculation) - 52 cells total, index 0-51
        ].slice(0, 52), // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³Ø§Ø± 52 Ø®Ù„ÙŠØ© ÙÙ‚Ø· (0-51)
        // Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ø¨ÙŠØª (4 Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨)
        HOME: [
            [{x: 1.5, y: 10.5}, {x: 1.5, y: 12.5}, {x: 3.5, y: 10.5}, {x: 3.5, y: 12.5}], // Red (0)
            [{x: 1.5, y: 1.5}, {x: 1.5, y: 3.5}, {x: 3.5, y: 1.5}, {x: 3.5, y: 3.5}],   // Blue (1)
            [{x: 10.5, y: 1.5}, {x: 10.5, y: 3.5}, {x: 12.5, y: 1.5}, {x: 12.5, y: 3.5}], // Green (2)
            [{x: 10.5, y: 10.5}, {x: 10.5, y: 12.5}, {x: 12.5, y: 10.5}, {x: 12.5, y: 12.5}], // Yellow (3) 
        ],
        // Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© (6 Ø®Ø§Ù†Ø§Øª Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨)
        FINAL_PATH: [
            [{x: 7.5, y: 13.5}, {x: 7.5, y: 12.5}, {x: 7.5, y: 11.5}, {x: 7.5, y: 10.5}, {x: 7.5, y: 9.5}, {x: 7.5, y: 8.5}], // Red (0)
            [{x: 1.5, y: 7.5}, {x: 2.5, y: 7.5}, {x: 3.5, y: 7.5}, {x: 4.5, y: 7.5}, {x: 5.5, y: 7.5}, {x: 6.5, y: 7.5}], // Blue (1)
            [{x: 7.5, y: 1.5}, {x: 7.5, y: 2.5}, {x: 7.5, y: 3.5}, {x: 7.5, y: 4.5}, {x: 7.5, y: 5.5}, {x: 7.5, y: 6.5}], // Green (2)
            [{x: 13.5, y: 7.5}, {x: 12.5, y: 7.5}, {x: 11.5, y: 7.5}, {x: 10.5, y: 7.5}, {x: 9.5, y: 7.5}, {x: 8.5, y: 7.5}], // Yellow (3)
        ],
        // Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ
        GOAL: {x: 7.5, y: 7.5}
    };

    // ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª (0-15) Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¨ÙƒØ³Ù„
    function toPixel(unit) {
        return unit * (CANVAS.width / 15);
    }

    // Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨ (Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ 0-51)
    const START_POSITIONS = [0, 13, 26, 39]; // 0: Red, 13: Blue, 26: Green, 39: Yellow

    //================================================================================
    // 2. ÙØ¦Ø© Ø§Ù„ØµÙˆØª (Base64 Audio Generation)
    //================================================================================

    class SoundManager {
        constructor() {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.muted = localStorage.getItem('ludoMuted') === 'true';
            this.buffers = {};
            this.loadSounds();
            document.getElementById('mute-button').textContent = this.muted ? 'ğŸ”‡' : 'ğŸ”Š';
        }

        async loadSounds() {
            // Ø¨ÙŠØ§Ù†Ø§Øª PCM Ø¨Ø³ÙŠØ·Ø© Ù„ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ø£ØµÙˆØ§Øª (Ù†ØºÙ…Ø§Øª Ù‚ØµÙŠØ±Ø©)
            const sounds = {
                DICE: [0.1, 800, 0.05, 1000, 0.05, 600, 0.05, 1200], // Ù…ØªØ°Ø¨Ø°Ø¨ ÙˆÙ‚ØµÙŠØ±
                MOVE: [0.15, 600], // Ù†ØºÙ…Ø© Ù‚ØµÙŠØ±Ø©
                CAPTURE: [0.1, 1500, 0.1, 300], // Ù†ØºÙ…ØªØ§Ù† Ø­Ø§Ø¯ØªØ§Ù†
                WIN: [0.2, 1200, 0.1, 1500, 0.3, 1800], // ØªØªØ§Ø¨Ø¹ Ù†ØºÙ…Ø§Øª Ø§Ø­ØªÙØ§Ù„ÙŠØ©
            };

            for (const key in sounds) {
                this.buffers[key] = this.createBuffer(sounds[key]);
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ AudioBuffer Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª PCM Ù…Ø¨Ø³Ø·Ø© (Ø§Ù„Ø²Ù…Ù† Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠØŒ Ø§Ù„ØªØ±Ø¯Ø¯ Ø¨Ø§Ù„Ù‡Ø±ØªØ²)
        createBuffer(sequence) {
            const sampleRate = 44100;
            let totalDuration = 0;
            for (let i = 0; i < sequence.length; i += 2) {
                totalDuration += sequence[i];
            }

            const frameCount = sampleRate * totalDuration;
            const buffer = this.audioCtx.createBuffer(1, frameCount, sampleRate);
            const channel = buffer.getChannelData(0);

            let offset = 0;
            for (let i = 0; i < sequence.length; i += 2) {
                const duration = sequence[i];
                const frequency = sequence[i + 1];
                const segmentFrames = Math.floor(sampleRate * duration);

                for (let j = 0; j < segmentFrames; j++) {
                    const time = j / sampleRate;
                    // Ù…ÙˆØ¬Ø© Ø¬ÙŠØ¨ÙŠØ© Ø¨Ø³ÙŠØ·Ø©
                    channel[offset + j] = Math.sin(2 * Math.PI * frequency * time) * 0.5;
                }
                offset += segmentFrames;
            }
            return buffer;
        }

        play(key) {
            if (this.muted || !this.buffers[key]) return;

            const source = this.audioCtx.createBufferSource();
            source.buffer = this.buffers[key];
            source.connect(this.audioCtx.destination);
            source.start();
        }

        toggleMute() {
            this.muted = !this.muted;
            localStorage.setItem('ludoMuted', this.muted);
            document.getElementById('mute-button').textContent = this.muted ? 'ğŸ”‡' : 'ğŸ”Š';
        }
    }


    //================================================================================
    // 3. ÙØ¦Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© (Token, Player, GameState)
    //================================================================================

    class Token {
        constructor(id, playerId) {
            this.id = id;
            this.playerId = playerId;
            // 0-3: Home, 4-55: Path (4-55), 56-61: Final Path (56-61), 62: Goal
            this.position = this.id; // ÙŠØ¨Ø¯Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØª (0, 1, 2, 3)
            this.targetX = 0; // Ù„Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø³Ù„Ø³
            this.targetY = 0;
            this.isMoving = false;
            this.currentX = 0; // ØªÙ… Ø¥Ø¶Ø§ÙØªÙ‡ Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø³Ù„Ø³Ø©
            this.currentY = 0;
        }

        // ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø®Ù„ÙŠØ© Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
        getCoords() {
            const playerIdx = this.playerId;
            let coords;

            if (this.position < 4) { // ÙÙŠ Ø§Ù„Ø¨ÙŠØª (0, 1, 2, 3)
                coords = BOARD_CONFIG.HOME[playerIdx][this.position];
            } else if (this.position < 56) { // ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (Ø§Ù„Ù…ÙˆØ§Ø¶Ø¹ 4 Ø¥Ù„Ù‰ 55)
                // 4 Ù‡ÙŠ Ù†Ù‚Ø·Ø© Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¨ÙŠØª (Ø¨Ø¯Ø§ÙŠØ© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø·ÙˆØ§Øª)
                const playerStartIdx = START_POSITIONS[playerIdx]; // 0, 13, 26, 39
                const stepsFromStart = this.position - 4;
                const pathIndex = (playerStartIdx + stepsFromStart) % 52; // Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (0-51)
                coords = BOARD_CONFIG.PATH[pathIndex];
            } else if (this.position < 62) { // ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ (56 Ø¥Ù„Ù‰ 61)
                const finalPathIndex = this.position - 56;
                coords = BOARD_CONFIG.FINAL_PATH[playerIdx][finalPathIndex];
            } else { // ÙÙŠ Ø§Ù„Ù‡Ø¯Ù (62)
                coords = BOARD_CONFIG.GOAL;
            }

            return { x: toPixel(coords.x), y: toPixel(coords.y) };
        }
    }

    class Player {
        constructor(id, type, aiLevel = 'EASY') {
            this.id = id;
            this.color = PLAYER_COLORS[id].color;
            this.name = ARABIC_TEXT.PLAYER + (id + 1) + ' (' + PLAYER_COLORS[id].name + ')';
            this.type = type; // 'HUMAN' or 'AI'
            this.aiLevel = aiLevel; // 'EASY', 'MEDIUM', 'HARD'
            this.tokens = [new Token(0, id), new Token(1, id), new Token(2, id), new Token(3, id)];
        }
    }

    class LudoGame {
        constructor() {
            this.players = [];
            this.currentPlayerIdx = 0;
            this.diceValue = 0;
            this.hasExtraTurn = false;
            this.sixStreak = 0;
            this.isRolling = false;
            this.isAnimating = false;
            this.winner = null;
            this.activePlayers = []; // Ø§Ù„Ù„Ø§Ø¹Ø¨ÙˆÙ† Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙˆÙ†
            this.validMoves = {}; // {tokenId: targetPosition}
            this.selectedToken = null;
            this.sm = new SoundManager();
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…Ø®ØªØ§Ø±ÙŠÙ†
        setupGame(playerConfigs) {
            this.players = [];
            this.activePlayers = [];
            this.currentPlayerIdx = 0;
            this.sixStreak = 0;
            this.winner = null;

            playerConfigs.forEach((config, id) => {
                const player = new Player(id, config.type, config.aiLevel);
                this.players.push(player);
                this.activePlayers.push(id);
                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙŠØª
                player.tokens.forEach((token, i) => token.position = i);
            });
            this.updateStatus(ARABIC_TEXT.START_NEW);
            this.diceValue = 0; 
            this.nextTurn();
            this.saveGame();
            this.renderer.render(); // ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø±Ø³Ù… Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©
        }

        // ØªØ­Ù…ÙŠÙ„ Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ù† localStorage
        loadGame(state) {
            this.activePlayers = state.activePlayers;
            this.players = state.players.map(pState => {
                const player = new Player(pState.id, pState.type, pState.aiLevel);
                player.tokens = pState.tokens.map(tState => {
                    const token = new Token(tState.id, tState.playerId);
                    token.position = tState.position;
                    return token;
                });
                return player;
            });
            this.currentPlayerIdx = state.currentPlayerIdx;
            this.diceValue = state.diceValue;
            this.sixStreak = state.sixStreak || 0;
            this.winner = state.winner;
            this.hasExtraTurn = state.hasExtraTurn || false;
            this.updateStatus(ARABIC_TEXT.GAME_SAVED);

            // Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø­Ø±ÙƒØ© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¯ÙˆØ± AI
            if (this.isAIPlayer(this.currentPlayerIdx) && !this.winner) {
                this.handleAI();
            } else if (!this.winner) {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù‚ÙŠÙ…Ø© Ù†Ø±Ø¯ Ù…Ø­ÙÙˆØ¸Ø©ØŒ Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø©
                if (this.diceValue !== 0) {
                     this.validMoves = this.getValidMoves(this.diceValue);
                }
                this.updateRollButton();
                this.renderer.highlightValidMoves(this.validMoves);
            }
        }

        saveGame() {
            const state = {
                players: this.players.map(p => ({
                    id: p.id,
                    type: p.type,
                    aiLevel: p.aiLevel,
                    tokens: p.tokens.map(t => ({
                        id: t.id,
                        playerId: t.playerId,
                        position: t.position
                    }))
                })),
                currentPlayerIdx: this.currentPlayerIdx,
                diceValue: this.diceValue,
                sixStreak: this.sixStreak,
                hasExtraTurn: this.hasExtraTurn,
                activePlayers: this.activePlayers,
                winner: this.winner
            };
            localStorage.setItem('ludoState', JSON.stringify(state));
            document.getElementById('resume-game').style.display = localStorage.getItem('ludoState') ? 'inline-block' : 'none';
        }

        // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„ØªØ§Ù„ÙŠ
        nextPlayer() {
            let nextIndex = (this.activePlayers.indexOf(this.currentPlayerIdx) + 1) % this.activePlayers.length;
            this.currentPlayerIdx = this.activePlayers[nextIndex];
            this.sixStreak = 0;
            this.hasExtraTurn = false;
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù„ÙŠ
        nextTurn() {
            if (this.winner) {
                this.showWinModal(this.winner);
                return;
            }

            // Ù„Ø§ Ù†Ù†ØªÙ‚Ù„ Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„ØªØ§Ù„ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠÙ‡ Ø¯ÙˆØ± Ø¥Ø¶Ø§ÙÙŠ (6)
            if (!this.hasExtraTurn || this.diceValue === 0) {
                this.nextPlayer();
            }
            
            this.diceValue = 0;
            this.renderer.highlightValidMoves({});
            this.selectedToken = null;
            this.updateRollButton();
            this.renderer.drawDiceValue(this.diceValue); // ØªØµÙÙŠØ± Ø§Ù„Ù†Ø±Ø¯ ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©

            if (this.isAIPlayer(this.currentPlayerIdx)) {
                this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name);
                setTimeout(() => this.rollDice(), 1000);
            } else {
                this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLL_DICE);
            }
        }

        isAIPlayer(id) {
            // ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ© Ù‚Ø¨Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø®Ø§ØµÙŠØ©
            if (!this.players[id]) return false; 
            return this.players[id].type === 'AI';
        }

        // Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯
        rollDice() {
            if (this.isRolling || this.isAnimating || this.diceValue !== 0) return;

            this.sm.play('DICE');
            this.isRolling = true;
            document.getElementById('roll-dice-button').disabled = true;

            let rollCount = 0;
            const maxRolls = 15;
            const rollInterval = setInterval(() => {
                rollCount++;
                this.diceValue = Math.floor(Math.random() * 6) + 1;
                this.renderer.drawDiceValue(this.diceValue); // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù†Ø±Ø¯

                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    this.isRolling = false;
                    this.afterDiceRoll();
                }
            }, 80);
        }

        // Ù…Ø§ Ø¨Ø¹Ø¯ Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯
        afterDiceRoll() {
            this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLLED + this.diceValue);

            const isSix = this.diceValue === 6;

            if (isSix) {
                this.sixStreak++;
                if (this.sixStreak === 3) {
                    this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - 3 Ø³ØªØ§Øª Ù…ØªØªØ§Ù„ÙŠØ©ØŒ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø¯ÙˆØ±!');
                    setTimeout(() => {
                        this.sixStreak = 0;
                        this.hasExtraTurn = false; 
                        this.diceValue = 0; 
                        this.nextTurn();
                    }, 1500);
                    return;
                } else {
                    this.hasExtraTurn = true;
                    this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLLED + this.diceValue + ' - ' + ARABIC_TEXT.EXTRA_TURN);
                }
            } else {
                this.hasExtraTurn = false;
                this.sixStreak = 0;
            }

            this.validMoves = this.getValidMoves(this.diceValue);
            this.renderer.highlightValidMoves(this.validMoves);

            if (Object.keys(this.validMoves).length === 0) {
                // Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª ØµØ§Ù„Ø­Ø©
                this.updateStatus(ARABIC_TEXT.NO_MOVES);
                this.diceValue = 0; // ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø±Ø¯ Ø­ØªÙ‰ Ù„Ùˆ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ø±ÙƒØ©
                setTimeout(() => this.nextTurn(), 1500);
            } else if (this.isAIPlayer(this.currentPlayerIdx)) {
                this.handleAI();
            } else {
                this.updateRollButton();
            }
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¯ÙˆØ± Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        handleAI() {
            const ai = new AI(this);
            const player = this.players[this.currentPlayerIdx];
            const bestMove = ai.chooseBestMove(player.aiLevel, this.diceValue, this.validMoves);

            if (bestMove) {
                const token = player.tokens.find(t => t.id === bestMove.tokenId);
                setTimeout(() => this.moveToken(token, bestMove.targetPosition), 1500);
            } else {
                // Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ù…ØªØ§Ø­Ø© Ù„Ù€ AI (ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ afterDiceRoll)
                setTimeout(() => this.nextTurn(), 1500);
            }
        }

        // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„ØµØ§Ù„Ø­Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹
        getValidMoves(dice) {
            const validMoves = {};
            const player = this.players[this.currentPlayerIdx];

            if (dice === 0) return {};

            player.tokens.forEach(token => {
                let targetPos = -1;

                if (token.position < 4) { // ÙÙŠ Ø§Ù„Ø¨ÙŠØª (0, 1, 2, 3)
                    if (dice === 6) {
                        targetPos = 4; // Ø§Ù„Ø®Ø§Ù†Ø© 4 ØªÙ…Ø«Ù„ Ù†Ù‚Ø·Ø© Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¨ÙŠØª
                    }
                } else if (token.position < 56) { // ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (4 Ø¥Ù„Ù‰ 55)
                    // 55 Ù‡ÙŠ Ø¢Ø®Ø± Ø®Ø§Ù†Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ù„Ù‰ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† (56)
                    
                    const stepsToFinalPath = 56 - token.position; // 56 Ù‡Ùˆ Ø£ÙˆÙ„ Ø®Ø§Ù†Ø© ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù†
                    
                    if (dice < stepsToFinalPath) {
                        targetPos = token.position + dice;
                    } else if (dice >= stepsToFinalPath) {
                        const finalPathIndex = dice - stepsToFinalPath;
                        if (finalPathIndex <= 6) { // 6 Ø®Ø§Ù†Ø§Øª ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† + Ø§Ù„Ù‡Ø¯Ù
                            targetPos = 56 + finalPathIndex; // 56 Ø¥Ù„Ù‰ 62
                        }
                    }
                } else if (token.position >= 56 && token.position < 62) { // ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ (56 Ø¥Ù„Ù‰ 61)
                    targetPos = token.position + dice;

                    if (targetPos > 62) {
                         targetPos = -1; // Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù‡Ø¯Ù (62)
                    }
                }
                
                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù‡Ø¯Ù Ù„ÙŠØ³ ØªØ¬Ø§ÙˆØ²Ø§Ù‹ (Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ù† Ø§Ù„Ù‡Ø¯Ù)
                if (token.position === 62) {
                    targetPos = -1;
                }

                if (targetPos !== -1) {
                    validMoves[token.id] = targetPos;
                }
            });
            return validMoves;
        }

        // ØªÙ†ÙÙŠØ° Ø­Ø±ÙƒØ© Ø§Ù„Ù‚Ø·Ø¹Ø©
        moveToken(token, targetPosition) {
            if (this.isAnimating) return;

            // Ø¨Ø¯Ø¡ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø³Ù„Ø³Ø©
            this.isAnimating = true;
            this.renderer.highlightValidMoves({}); // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¸Ù„ÙŠÙ„ Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ø­Ø±ÙƒØ©
            
            // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø±Ø¯ Ù„Ù„Ø­Ø¸Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù…Ù†Ø¹ Ø§Ù„Ù†Ù‚Ø±
            this.updateRollButton(); 

            this.renderer.startTokenAnimation(token, targetPosition, () => {
                this.isAnimating = false;
                this.sm.play('MOVE');

                // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø¹Ø¯ ÙˆØµÙˆÙ„ Ø§Ù„Ù‚Ø·Ø¹Ø© (ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ 4-55)
                const oldPosition = token.position;
                token.position = targetPosition; // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆØ¶Ø¹ Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                
                if (targetPosition >= 4 && targetPosition < 56) {
                    this.checkCapture(token, targetPosition);
                }

                this.saveGame();

                // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                this.checkWin(token.playerId);

                // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù„ÙŠ (Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ)
                this.diceValue = 0; // ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø±Ø¯
                this.nextTurn();
            });
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
        checkCapture(movingToken, targetPosition) {
            const pathIndex = this.convertToGlobalPathIndex(movingToken.playerId, targetPosition);
            const isSafeSpot = this.isGlobalSafeSpot(pathIndex);

            if (isSafeSpot) return;

            this.players.forEach(player => {
                if (player.id !== movingToken.playerId) {
                    player.tokens.forEach(opponentToken => {
                        // Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¶Ø±Ø¨ Ù‚Ø·Ø¹Ø© ÙÙŠ Ø§Ù„Ø¨ÙŠØª Ø£Ùˆ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù†
                        if (opponentToken.position < 4 || opponentToken.position >= 56) return;
                        
                        // Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø®ØµÙ… ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ
                        const opponentPathPos = this.convertToGlobalPathIndex(opponentToken.playerId, opponentToken.position);

                        if (pathIndex === opponentPathPos) {
                            // Ø§ØµØ·Ø¯Ø§Ù…! Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙŠØª (Ø§Ù„Ù…ÙˆØ¶Ø¹ 0-3)
                            opponentToken.position = opponentToken.id;
                            this.sm.play('CAPTURE');
                            this.updateStatus(this.players[movingToken.playerId].name + ' Ø¶Ø±Ø¨ Ù‚Ø·Ø¹Ø© Ù„Ù€ ' + player.name);
                        }
                    });
                }
            });
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø© (4-55) Ø¥Ù„Ù‰ Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (0-51)
        convertToGlobalPathIndex(playerId, position) {
             const playerStartIdx = START_POSITIONS[playerId];
             const stepsFromStart = position - 4;
             return (playerStartIdx + stepsFromStart) % 52;
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù…Ø¹Ø±ÙØ© Ù‡Ù„ Ø§Ù„Ø®Ø§Ù†Ø© Ø¢Ù…Ù†Ø©
        isGlobalSafeSpot(pathIndex) {
            return SAFE_SPOTS.includes(pathIndex) || START_SPOTS.includes(pathIndex);
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
        checkWin(playerId) {
            const player = this.players[playerId];
            const allTokensInGoal = player.tokens.every(token => token.position === 62);
            if (allTokensInGoal) {
                this.winner = playerId;
                this.showWinModal(playerId);
                localStorage.removeItem('ludoState'); // Ù…Ø³Ø­ Ø­Ø§Ù„Ø© Ø§Ù„Ø­ÙØ¸
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø±Ø¶ (Ø§Ù„Ù†ØµÙˆØµ)
        updateStatus(message) {
            document.getElementById('status-display').textContent = message;
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø²Ø± Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯
        updateRollButton() {
            const rollButton = document.getElementById('roll-dice-button');
            const currentPlayer = this.players[this.currentPlayerIdx];

            if (this.winner) {
                rollButton.disabled = true;
                rollButton.textContent = 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©';
            } else if (currentPlayer.type === 'AI' || this.isRolling || this.isAnimating) {
                rollButton.disabled = true;
                rollButton.textContent = 'Ø¯ÙˆØ± Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...';
            } else if (this.diceValue === 0) {
                rollButton.disabled = false;
                rollButton.textContent = ARABIC_TEXT.ROLL_DICE;
            } else {
                // Ø¨Ø¹Ø¯ Ø§Ù„Ø±Ù…ÙŠ ÙˆÙˆØ¬ÙˆØ¯ Ø­Ø±ÙƒØ§Øª ØµØ§Ù„Ø­Ø©ØŒ ÙŠØ¬Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø·Ø¹Ø©
                rollButton.disabled = true;
                rollButton.textContent = 'Ø§Ø®ØªØ± Ù‚Ø·Ø¹Ø©';
            }
        }

        showWinModal(winnerId) {
            const winnerName = this.players[winnerId].name;
            document.getElementById('winner-message').textContent = ARABIC_TEXT.WINNER_IS + winnerName;
            document.getElementById('win-modal').classList.add('active');
            this.sm.play('WIN');
            this.renderer.render(); // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø£Ø®ÙŠØ±Ø©
        }

        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ø·Ø¹Ø© Ù„Ù„Ù†Ù‚Ù„
        selectToken(token) {
            if (this.isAIPlayer(this.currentPlayerIdx) || this.isRolling || this.isAnimating || this.diceValue === 0 || this.winner) return;
            if (token.playerId !== this.currentPlayerIdx) return; // Ù‚Ø·Ø¹Ø© Ù„Ø§Ø¹Ø¨ Ø¢Ø®Ø±

            const targetPos = this.validMoves[token.id];

            if (targetPos !== undefined) {
                this.selectedToken = token;
                this.moveToken(token, targetPos);
            }
        }
    }


    //================================================================================
    // 4. ÙØ¦Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ (AI)
    //================================================================================

    class AI {
        constructor(game) {
            this.game = game;
            this.playerId = game.currentPlayerIdx;
            this.player = game.players[this.playerId];
            this.opponentTokens = this.getOpponentTokens();
        }

        getOpponentTokens() {
            return this.game.players
                .filter(p => p.id !== this.playerId)
                .flatMap(p => p.tokens)
                .filter(t => t.position >= 4 && t.position < 56);
        }

        // Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
        chooseBestMove(level, diceValue, validMoves) {
            const moves = Object.entries(validMoves).map(([tokenId, targetPosition]) => ({
                tokenId: parseInt(tokenId),
                targetPosition: targetPosition
            }));

            if (moves.length === 0) return null;

            if (level === 'EASY') {
                return this.easyMove(moves, diceValue);
            } else if (level === 'MEDIUM') {
                return this.mediumMove(moves, diceValue);
            } else { // HARD
                return this.hardMove(moves, diceValue);
            }
        }

        // Ø³Ù‡Ù„: ÙŠØ¯Ø®Ù„ Ø¨Ø§Ù„Ù€ 6ØŒ ÙŠØ­Ø±Ùƒ Ø£ÙˆÙ„ Ù‚Ø·Ø¹Ø© Ù…ØªØ§Ø­Ø© (Ø§Ù„Ø£Ù‚Ù„ ID)
        easyMove(moves, diceValue) {
            // Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ù„Ø±Ù…ÙŠ 6 Ù„Ù„Ø¯Ø®ÙˆÙ„
            if (diceValue === 6) {
                const homeMove = moves.find(m => this.player.tokens.find(t => t.id === m.tokenId).position < 4);
                if (homeMove) return homeMove;
            }
            // Ø§Ø®ØªÙŠØ§Ø± Ø£ÙˆÙ„ Ø­Ø±ÙƒØ© Ù…ØªØ§Ø­Ø©
            return moves[0];
        }

        // Ù…ØªÙˆØ³Ø·: ÙŠÙØ¶Ù‘Ù„ Ø§Ù„Ø¶Ø±Ø¨ØŒ ÙŠØªØ¬Ù†Ø¨ Ø§Ù„Ø®Ø·Ø±ØŒ ÙŠÙˆØ²Ø¹ Ø§Ù„ØªÙ‚Ø¯Ù…
        mediumMove(moves, diceValue) {
            let bestMove = null;
            let maxScore = -Infinity;

            for (const move of moves) {
                const score = this.evaluateMove(move.tokenId, move.targetPosition, diceValue, 'MEDIUM');
                if (score > maxScore) {
                    maxScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        // ØµØ¹Ø¨: ØªÙ‚ÙŠÙŠÙ… Ù†Ù‚Ø§Ø· Ù…ØªÙˆØ§Ø²Ù† (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ù„Ù„Ø¶Ø±Ø¨ØŒ Ø§Ù„ØªÙ‚Ø¯Ù… Ø§Ù„Ø¢Ù…Ù†ØŒ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø£Ù‚Ø±Ø¨ Ù„Ù„Ù‡Ø¯Ù)
        hardMove(moves, diceValue) {
            let bestMove = null;
            let maxScore = -Infinity;

            for (const move of moves) {
                const score = this.evaluateMove(move.tokenId, move.targetPosition, diceValue, 'HARD');
                if (score > maxScore) {
                    maxScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        // Ø¯Ø§Ù„Ø© ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø­Ø±ÙƒØ©
        evaluateMove(tokenId, targetPosition, diceValue, level) {
            let score = 0;
            const token = this.player.tokens.find(t => t.id === tokenId);

            // 1. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¶Ø±Ø¨/Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… (Capture)
            const capturedToken = this.isCaptureMove(targetPosition, token.playerId);
            if (capturedToken) {
                score += 100; // Ù‚ÙŠÙ…Ø© Ø¹Ø§Ù„ÙŠØ© Ù„Ù„Ø¶Ø±Ø¨
            }

            // 2. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù (Goal)
            if (targetPosition === 62) {
                score += 500; // Ù‚ÙŠÙ…Ø© Ø¹Ø§Ù„ÙŠØ© Ù„Ù„ÙÙˆØ²/Ø§Ù„ÙˆØµÙˆÙ„
            }

            // 3. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¨ÙŠØª
            if (token.position < 4 && targetPosition === 4) {
                score += 50;
            }

            // 4. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªÙ‚Ø¯Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© (Ø£Ù‚Ù„ Ù‚ÙŠÙ…Ø© Ø¥Ø¬Ù…Ø§Ù„ÙŠØ© = Ø£Ù‚Ø±Ø¨ Ù„Ù„Ù‡Ø¯Ù)
            // Ù…Ø³Ø§ÙØ© Ø§Ù„Ù‡Ø¯Ù (62 - targetPosition)
            score += (62 - targetPosition) * -2;

            // 5. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£Ù…Ø§Ù† (Threat Avoidance)
            if (targetPosition >= 4 && targetPosition < 56) {
                const pathIndex = this.convertToGlobalPathIndex(token.playerId, targetPosition);
                const isSafe = this.isGlobalSafeSpot(pathIndex);

                if (!isSafe) {
                    // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯Ø§Øª Ø§Ù„Ù‚Ø±ÙŠØ¨Ø© (Threat)
                    const threats = this.getThreats(pathIndex);
                    if (threats.length > 0) {
                        score -= 80; // Ø¹Ù‚ÙˆØ¨Ø© Ù„Ù„ÙˆÙ‚ÙˆÙ ÙÙŠ Ù…ÙƒØ§Ù† ØºÙŠØ± Ø¢Ù…Ù† Ù…Ù‡Ø¯Ø¯
                    }
                }
            }

            // 6. Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ù„Ù‰ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ
            if (targetPosition >= 56 && token.position < 56) {
                 score += 70;
            }

            // 7. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø®Ø·Ø± (ÙÙ‚Ø· Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹Ø¨)
            if (level === 'HARD') {
                if (targetPosition >= 4 && targetPosition < 56) {
                    const isSafe = this.isGlobalSafeSpot(this.convertToGlobalPathIndex(token.playerId, targetPosition));
                    if (!isSafe) {
                        // Ù‡Ù„ Ø§Ù„Ù‚Ø·Ø¹Ø© Ù…Ø¹Ø±Ø¶Ø© Ù„Ù„Ø¶Ø±Ø¨ ÙÙŠ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù„ÙŠ Ù„Ù„Ø®ØµÙ…ØŸ (Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† 1-6 Ø®Ø·ÙˆØ§Øª)
                        const nextTurnThreats = this.getFutureThreats(targetPosition);
                        if (nextTurnThreats.length > 0) {
                            score -= 150; // Ø¹Ù‚ÙˆØ¨Ø© Ø£ÙƒØ¨Ø± Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¹Ø±ÙŠØ¶ Ù„Ù„Ø®Ø·Ø±
                        }
                    }
                }
            }

            return score;
        }

        // ØªØ­ÙˆÙŠÙ„ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø© (4-55) Ø¥Ù„Ù‰ Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (0-51)
        convertToGlobalPathIndex(playerId, position) {
            const playerStartIdx = START_POSITIONS[playerId];
            const stepsFromStart = position - 4;
            return (playerStartIdx + stepsFromStart) % 52;
        }

        // Ù‡Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§Ù†Ø© Ø¢Ù…Ù†Ø©ØŸ
        isGlobalSafeSpot(pathIndex) {
            return SAFE_SPOTS.includes(pathIndex) || START_SPOTS.includes(pathIndex);
        }

        // Ù‡Ù„ Ù‡Ù†Ø§Ùƒ Ù‚Ø·Ø¹Ø© Ø®ØµÙ… ÙŠÙ…ÙƒÙ† Ø¶Ø±Ø¨Ù‡Ø§ ÙÙŠ targetPositionØŸ
        isCaptureMove(targetPosition, movingPlayerId) {
            if (targetPosition < 4 || targetPosition >= 56) return null; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¶Ø±Ø¨ ÙÙŠ Ø§Ù„Ø¨ÙŠØª Ø£Ùˆ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù†

            const pathIndex = this.convertToGlobalPathIndex(movingPlayerId, targetPosition);
            if (this.isGlobalSafeSpot(pathIndex)) return null; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¶Ø±Ø¨ ÙÙŠ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ø¢Ù…Ù†Ø©

            return this.opponentTokens.find(t => {
                const opponentPathIndex = this.convertToGlobalPathIndex(t.playerId, t.position);
                return pathIndex === opponentPathIndex;
            });
        }

        // Ø¬Ù„Ø¨ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ù‚Ø·Ø¹ Ø§Ù„Ø®ØµÙ… Ø§Ù„ÙˆØ§Ù‚ÙØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ù†Ø©)
        getThreats(pathIndex) {
            return this.opponentTokens.filter(t => {
                const opponentPathIndex = this.convertToGlobalPathIndex(t.playerId, t.position);
                return pathIndex === opponentPathIndex;
            });
        }

        // Ø¬Ù„Ø¨ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©: Ù‡Ù„ ÙŠÙ…ÙƒÙ† Ù„Ù„Ø®ØµÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ targetPosition ÙÙŠ Ø¯ÙˆØ± Ù‚Ø§Ø¯Ù…ØŸ
        getFutureThreats(targetPosition) {
            const targetPathIndex = this.convertToGlobalPathIndex(this.playerId, targetPosition);
            let threats = [];

            for (const opponentToken of this.opponentTokens) {
                const opponentPlayerId = opponentToken.playerId;
                const opponentGlobalPos = this.convertToGlobalPathIndex(opponentPlayerId, opponentToken.position);

                // Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ØªÙŠ ÙŠØ­ØªØ§Ø¬Ù‡Ø§ Ø§Ù„Ø®ØµÙ… Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‡Ø¯ÙÙƒ
                const distance = (targetPathIndex - opponentGlobalPos + 52) % 52; 

                if (distance >= 1 && distance <= 6) {
                    threats.push(opponentToken);
                }
            }
            return threats;
        }
    }


    //================================================================================
    // 5. ÙØ¦Ø© Ø§Ù„Ø±Ø³Ø§Ù… (Renderer)
    //================================================================================

    class Renderer {
        constructor(game) {
            this.game = game;
            this.cellSize = 0;
            this.tokenRadius = 0;
            this.highlightedMoves = {};
            this.activeAnimation = null;
            this.resizeCanvas();
            window.addEventListener('resize', this.resizeCanvas.bind(this));
            CANVAS.addEventListener('click', this.handleCanvasClick.bind(this));
            CANVAS.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = CANVAS.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                this.handleClick(x, y);
            });
        }

        resizeCanvas() {
            const containerWidth = document.getElementById('game-container').clientWidth - 30; // 30 = padding
            CANVAS.width = containerWidth;
            CANVAS.height = containerWidth;
            this.cellSize = CANVAS.width / 15;
            this.tokenRadius = this.cellSize * 0.4;
            this.game.renderer = this; // ØªØ­Ø¯ÙŠØ« Ù…Ø±Ø¬Ø¹ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù€ this.cellSize
            this.render();
        }

        // Ø±Ø³Ù… Ø§Ù„Ù„ÙˆØ­Ø© ÙƒØ§Ù…Ù„Ø©
        render() {
            // Ù„Ø§ ØªØ±Ø³Ù… Ø¨Ø¯ÙˆÙ† ØªÙ‡ÙŠØ¦Ø© Ø¥Ù„Ø§ Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
            CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
            this.drawBoardStructure();
            if (this.game.players.length) {
                 this.drawTokens();
            }
        }

        drawBoardStructure() {
            const cs = this.cellSize;

            // 1. Ø±Ø³Ù… Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ÙˆØ³Ø· (Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª ÙˆØ§Ù„Ù‡Ø¯Ù)
            CTX.fillStyle = '#f0f0f0';
            CTX.fillRect(6 * cs, 0 * cs, 3 * cs, 15 * cs); // Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø£ÙÙ‚ÙŠ
            CTX.fillRect(0 * cs, 6 * cs, 15 * cs, 3 * cs); // Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ

            // 2. Ø±Ø³Ù… Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø¨ÙŠÙˆØª (Corners)
            for (let i = 0; i < 4; i++) {
                CTX.fillStyle = PLAYER_COLORS[i].light;
                
                // ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¨ÙŠØª 6x6
                const x = (i === 0 || i === 1) ? 0 : 9 * cs;
                const y = (i === 0 || i === 3) ? 9 * cs : 0; 
                
                CTX.fillRect(x, y, 6 * cs, 6 * cs);

                CTX.strokeStyle = '#333';
                CTX.lineWidth = 2;
                CTX.strokeRect(x, y, 6 * cs, 6 * cs); // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¨ÙŠØª Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©
            }

            // 3. Ø±Ø³Ù… Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ (Ø§Ù„Ø­Ø¯ÙˆØ¯ ÙˆØ§Ù„ØªÙ„ÙˆÙŠÙ†)
            // Ù†Ø­ØªØ§Ø¬ Ù„Ø±Ø³Ù… ÙƒÙ„ Ø®Ù„ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ ÙˆØ§Ù„Ø¯Ø§Ø®Ù„ÙŠ
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    // Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ù…Ø³Ø§Ø± (Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¨ÙŠÙˆØª)
                    const isTrack = (j >= 6 && j <= 8) || (i >= 6 && i <= 8);
                    const isCorner = (i < 6 && j < 6) || (i >= 9 && j < 6) || (i < 6 && j >= 9) || (i >= 9 && j >= 9);
                    
                    if (isTrack && !isCorner) {
                        CTX.strokeStyle = '#333';
                        CTX.lineWidth = 1;
                        CTX.strokeRect(i * cs, j * cs, cs, cs);
                        
                        // ØªÙ„ÙˆÙŠÙ† Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù† Ø¨Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨
                        if (i === 7 && j >= 9 && j <= 13) CTX.fillStyle = PLAYER_COLORS[0].color; // Red Final Path
                        else if (j === 7 && i >= 1 && i <= 5) CTX.fillStyle = PLAYER_COLORS[1].color; // Blue Final Path
                        else if (i === 7 && j >= 1 && j <= 5) CTX.fillStyle = PLAYER_COLORS[2].color; // Green Final Path
                        else if (j === 7 && i >= 9 && i <= 13) CTX.fillStyle = PLAYER_COLORS[3].color; // Yellow Final Path
                        else CTX.fillStyle = '#fff';

                        CTX.fillRect(i * cs, j * cs, cs, cs);
                        CTX.strokeStyle = '#333';
                        CTX.lineWidth = 1;
                        CTX.strokeRect(i * cs, j * cs, cs, cs);
                    }
                }
            }

            // 4. Ø±Ø³Ù… Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ (Goal)
            CTX.fillStyle = '#f0f0f0';
            CTX.beginPath();
            // Ø±Ø³Ù… Ø§Ù„Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø§Ø³ÙŠ
            CTX.moveTo(7.5 * cs, 7.5 * cs);
            CTX.lineTo(6 * cs, 6 * cs);
            CTX.lineTo(9 * cs, 6 * cs);
            CTX.lineTo(9 * cs, 9 * cs);
            CTX.lineTo(6 * cs, 9 * cs);
            CTX.closePath();
            CTX.fill();

            // 5. ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ø¢Ù…Ù†Ø© (Ø¨Ø§Ù„Ù†Ø¬Ù…Ø©)
            CTX.textAlign = 'center';
            CTX.textBaseline = 'middle';
            CTX.font = `${cs * 0.7}px Arial`;

            // Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ø¨ÙŠÙˆØª Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© (Ù„Ø¹Ø¨Ø© Ø§Ù„Ù„ÙŠØ¯Ùˆ Ø§Ù„Ø£ØµÙ„ÙŠØ© ØªØ±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© Ø­ÙˆÙ„ Ù…ÙƒØ§Ù† Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©)
            for (let i = 0; i < 4; i++) {
                const homeCoords = BOARD_CONFIG.HOME[i];
                CTX.strokeStyle = '#333';
                CTX.lineWidth = 1.5;
                homeCoords.forEach(c => {
                    CTX.beginPath();
                    CTX.arc(toPixel(c.x), toPixel(c.y), this.tokenRadius * 1.3, 0, 2 * Math.PI);
                    CTX.stroke();
                });
            }

            // Ø±Ø³Ù… Ø§Ù„Ù†Ø¬ÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ø¢Ù…Ù†Ø© ÙˆØ®Ø§Ù†Ø§Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
            SAFE_SPOTS.concat(START_SPOTS).forEach(index => {
                const coords = BOARD_CONFIG.PATH[index];
                
                // ØªØ­Ø¯ÙŠØ¯ Ù„ÙˆÙ† Ø®Ù„ÙÙŠØ© Ø§Ù„Ù†Ø¬Ù…Ø©
                let starColor = '#fff';
                if (START_SPOTS.includes(index)) {
                     const playerIdx = START_SPOTS.indexOf(index);
                     starColor = PLAYER_COLORS[playerIdx].color;
                } else if (index === 1 || index === 14 || index === 27 || index === 40) {
                     const playerIdx = [1, 14, 27, 40].indexOf(index);
                     starColor = PLAYER_COLORS[playerIdx].color;
                }
                
                // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø®Ù„ÙÙŠØ© Ù„Ù„Ø®Ø§Ù†Ø© Ù„ØªÙƒÙˆÙ† Ù…Ù„ÙˆÙ†Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
                CTX.fillStyle = starColor;
                CTX.fillRect(coords.x * cs - cs / 2, coords.y * cs - cs / 2, cs, cs);
                CTX.strokeStyle = '#333';
                CTX.lineWidth = 1;
                CTX.strokeRect(coords.x * cs - cs / 2, coords.y * cs - cs / 2, cs, cs);


                // Ø±Ø³Ù… Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø£Ù…Ø§Ù† (Ù†Ø¬Ù…Ø©)
                CTX.fillStyle = 'white';
                CTX.fillText('â˜…', toPixel(coords.x), toPixel(coords.y) + 2);
            });

            // 6. ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø©
            this.highlightValidMoves(this.highlightedMoves, false); // Ù„Ø§ ØªØ±Ø³Ù… Ø§Ù„Ù‡ÙŠÙƒÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
        }

        highlightValidMoves(moves, redraw = true) {
            this.highlightedMoves = moves;

            if (redraw) {
                this.render();
            }

            if (Object.keys(moves).length === 0) return;

            const targetPositions = Object.values(moves);
            const cs = this.cellSize;

            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ø¶Ù…Ø§Ù† ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ø®Ø§Ù†Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
            const uniqueTargets = [...new Set(targetPositions)];

            uniqueTargets.forEach(pos => {
                let coords;
                // Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø·Ø¹Ø© Ù…Ø¤Ù‚ØªØ© ÙÙ‚Ø· Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù‡Ø¯Ù
                const tokenAtTarget = new Token(0, this.game.currentPlayerIdx);
                tokenAtTarget.position = pos;
                coords = tokenAtTarget.getCoords();

                // Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© ØªØ¸Ù„ÙŠÙ„ Ø­ÙˆÙ„ Ø§Ù„Ø®Ø§Ù†Ø©
                CTX.strokeStyle = 'gold';
                CTX.lineWidth = 4;
                CTX.beginPath();
                // ÙŠÙ…ÙƒÙ† ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ø®Ø§Ù†Ø© Ù†ÙØ³Ù‡Ø§ Ø£Ùˆ Ø§Ù„Ù‚Ø·Ø¹Ø©ØŒ Ù†Ø®ØªØ§Ø± Ø§Ù„Ø®Ø§Ù†Ø©
                CTX.arc(coords.x, coords.y, cs * 0.48, 0, 2 * Math.PI);
                CTX.stroke();
            });
        }

        // Ø±Ø³Ù… Ø§Ù„Ù‚Ø·Ø¹
        drawTokens() {
            this.game.players.forEach(player => {
                player.tokens.forEach(token => {
                    let { x, y } = token.getCoords();

                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© ÙÙŠ Ø­Ø§Ù„Ø© Ø­Ø±ÙƒØ©
                    if (token.isMoving) {
                        x = token.currentX;
                        y = token.currentY;
                    }

                    // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ÙˆØ§Ù‚ÙØ© ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø®Ø§Ù†Ø© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„
                    // Ù…Ù†Ø·Ù‚ Ø¨Ø³ÙŠØ·: Ø¥Ø²Ø§Ø­Ø© Ø®ÙÙŠÙØ© Ù„Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…ÙˆØ¶Ø¹
                    let offset = 0;
                    if (token.position >= 4 && token.position < 62) {
                        const tokensAtSameSpot = player.tokens.filter(t => t.position === token.position);
                        if (tokensAtSameSpot.length > 1) {
                            const index = tokensAtSameSpot.indexOf(token);
                            offset = (index - (tokensAtSameSpot.length - 1) / 2) * (this.tokenRadius * 0.5); // Ø¥Ø²Ø§Ø­Ø© Ø¨Ø³ÙŠØ·Ø©
                        }
                    }


                    CTX.fillStyle = player.color;
                    CTX.strokeStyle = '#333';
                    CTX.lineWidth = 2;

                    // Ø§Ù„Ø¸Ù„
                    CTX.shadowColor = 'rgba(0,0,0,0.4)';
                    CTX.shadowBlur = 4;
                    CTX.shadowOffsetX = 2;
                    CTX.shadowOffsetY = 2;

                    // Ø¬Ø³Ù… Ø§Ù„Ù‚Ø·Ø¹Ø©
                    CTX.beginPath();
                    CTX.arc(x + offset, y, this.tokenRadius, 0, 2 * Math.PI);
                    CTX.fill();
                    CTX.stroke();

                    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¸Ù„ Ù„Ù„Ø±Ø³Ù… Ø§Ù„ØªØ§Ù„ÙŠ
                    CTX.shadowBlur = 0;
                    CTX.shadowOffsetX = 0;
                    CTX.shadowOffsetY = 0;

                    // Ø±Ù‚Ù… Ø§Ù„Ù‚Ø·Ø¹Ø©
                    CTX.fillStyle = '#fff';
                    CTX.font = `${this.tokenRadius * 0.9}px Cairo, sans-serif`;
                    CTX.fillText((token.id + 1), x + offset, y + 2);
                });
            });
        }

        // Ø±Ø³Ù… Ù‚ÙŠÙ…Ø© Ø§Ù„Ù†Ø±Ø¯
        drawDiceValue(value) {
            document.getElementById('dice-display').textContent = value === 0 ? 'ğŸ²' : value;
        }

        // Ø¨Ø¯Ø¡ Ø­Ø±ÙƒØ© Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø³Ù„Ø³Ø© (Tweening)
        startTokenAnimation(token, targetPosition, callback) {
            token.isMoving = true;
            token.currentX = token.getCoords().x;
            token.currentY = token.getCoords().y;

            const startPos = token.position;
            const path = this.getAnimationPath(token.playerId, startPos, targetPosition);

            if (path.length === 0) {
                token.isMoving = false;
                callback();
                return;
            }

            let pathIndex = 0;
            const animationDuration = 100; // Ù…Ø¯Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ø¨ÙŠÙ† Ø®Ø§Ù†ØªÙŠÙ† (Ø¨Ø§Ù„Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©)
            let startTime = null;
            let currentPathStep = path[0];

            const step = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;

                if (elapsed < animationDuration) {
                    // Ø­Ø±ÙƒØ© Ø³Ù„Ø³Ø© (Tween)
                    const progress = elapsed / animationDuration;
                    token.currentX = currentPathStep.startX + (currentPathStep.endX - currentPathStep.startX) * progress;
                    token.currentY = currentPathStep.startY + (currentPathStep.endY - currentPathStep.startY) * progress;
                } else {
                    // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø®Ø§Ù†Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø±
                    token.currentX = currentPathStep.endX;
                    token.currentY = currentPathStep.endY;
                    pathIndex++;
                    startTime = timestamp; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙˆÙ‚Øª Ø§Ù„Ø¨Ø¯Ø¡ Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„ØªØ§Ù„ÙŠØ©

                    if (pathIndex >= path.length) {
                        // Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø­Ø±ÙƒØ©
                        token.isMoving = false;
                        this.game.isAnimating = false;
                        callback();
                        return;
                    }

                    // Ø§Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©
                    currentPathStep = path[pathIndex];
                }

                this.render();
                requestAnimationFrame(step);
            };

            this.game.isAnimating = true;
            requestAnimationFrame(step);
        }

        // Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ© Ù„Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
        getAnimationPath(playerId, startPos, targetPos) {
            const path = [];
            let currentPos = startPos;

            // Ù…Ø³Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ù‡Ùˆ Ø®Ø·ÙˆØ© Ø®Ø·ÙˆØ©ØŒ Ù„Ø°Ù„Ùƒ Ù†Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ÙƒÙ„ Ø®Ø§Ù†Ø© Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ø§Ù„Ø·Ø±ÙŠÙ‚
            while (currentPos !== targetPos) {
                let nextPos = currentPos + 1;
                
                // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© Ø³ØªØ¯Ø®Ù„ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù†ØŒ ÙØ¥Ù† Ø§Ù„Ù†Ù‚Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù‡ÙŠ 56
                if (currentPos < 56 && nextPos >= 56) nextPos = 56;
                // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© ÙˆØµÙ„Øª Ù„Ù„Ù‡Ø¯ÙØŒ ÙŠØ¬Ø¨ Ø£Ù† ØªØªÙˆÙ‚Ù
                if (currentPos >= 62) break;

                const tokenAtCurrent = new Token(0, playerId);
                tokenAtCurrent.position = currentPos;
                const startCoords = tokenAtCurrent.getCoords();

                const tokenAtNext = new Token(0, playerId);
                tokenAtNext.position = nextPos;
                const endCoords = tokenAtNext.getCoords();

                path.push({
                    startX: startCoords.x,
                    startY: startCoords.y,
                    endX: endCoords.x,
                    endY: endCoords.y,
                });

                currentPos = nextPos;
            }
            return path;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©
        handleClick(x, y) {
            if (this.game.isRolling || this.game.isAnimating || this.game.winner || this.game.isAIPlayer(this.game.currentPlayerIdx) || this.game.diceValue === 0) return;

            for (const player of this.game.players) {
                for (const token of player.tokens) {
                    const { x: tx, y: ty } = token.getCoords();
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ù‚Ø·Ø¹Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†Ù‚Ø±
                    const distSq = (x - tx) ** 2 + (y - ty) ** 2;

                    if (distSq < this.tokenRadius ** 2) {
                        // ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø·Ø¹Ø©
                        this.game.selectToken(token);
                        return;
                    }
                }
            }
        }

        handleCanvasClick(event) {
            const rect = CANVAS.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            this.handleClick(x, y);
        }
    }


    //================================================================================
    // 6. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    //================================================================================

    let game = new LudoGame();
    let renderer = new Renderer(game);
    game.renderer = renderer;

    // ØªÙ‡ÙŠØ¦Ø© Ø´Ø§Ø´Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    const playerCountSelect = document.getElementById('player-count');
    const playerConfigDiv = document.getElementById('player-config');

    function updatePlayerConfig() {
        const count = parseInt(playerCountSelect.value);
        playerConfigDiv.innerHTML = '<p style="font-weight: bold; margin-bottom: 10px;">Ù†ÙˆØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†:</p>';

        for (let i = 0; i < 4; i++) {
            const colorName = PLAYER_COLORS[i].name;
            const colorCode = PLAYER_COLORS[i].color;
            const isVisible = i < count;

            const row = document.createElement('div');
            row.className = 'player-setup-row';
            row.style.display = isVisible ? 'flex' : 'none';

            // Ù…Ø¤Ø´Ø± Ø§Ù„Ù„ÙˆÙ†
            const colorIndicator = document.createElement('div');
            colorIndicator.className = 'color-indicator';
            colorIndicator.style.backgroundColor = colorCode;

            // Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨
            const label = document.createElement('label');
            label.textContent = colorName;

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹ (Ø¨Ø´Ø±ÙŠ/Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ)
            const typeSelect = document.createElement('select');
            typeSelect.id = `player-type-${i}`;
            typeSelect.innerHTML = `<option value="HUMAN">${ARABIC_TEXT.HUMAN}</option><option value="AI">${ARABIC_TEXT.AI}</option>`;
            typeSelect.value = i === 0 ? 'HUMAN' : 'AI';

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ (ÙŠØ¸Ù‡Ø± ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† AI)
            const levelSelect = document.createElement('select');
            levelSelect.id = `ai-level-${i}`;
            levelSelect.innerHTML = `<option value="EASY">${ARABIC_TEXT.EASY}</option><option value="MEDIUM" selected>${ARABIC_TEXT.MEDIUM}</option><option value="HARD">${ARABIC_TEXT.HARD}</option>`;
            levelSelect.style.display = typeSelect.value === 'AI' ? 'block' : 'none';

            typeSelect.addEventListener('change', () => {
                levelSelect.style.display = typeSelect.value === 'AI' ? 'block' : 'none';
            });

            row.appendChild(colorIndicator);
            row.appendChild(label);
            row.appendChild(typeSelect);
            row.appendChild(levelSelect);
            playerConfigDiv.appendChild(row);
        }
    }

    playerCountSelect.addEventListener('change', updatePlayerConfig);

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„
    window.onload = function() {
        updatePlayerConfig();

        if (localStorage.getItem('ludoState')) {
            document.getElementById('resume-game').style.display = 'inline-block';
            document.getElementById('start-new-game').textContent = ARABIC_TEXT.START_NEW;
        } else {
             document.getElementById('resume-game').style.display = 'none';
             document.getElementById('start-new-game').textContent = ARABIC_TEXT.START_NEW;
        }
        
        // Ø±Ø³Ù… Ø§Ù„Ù„ÙˆØ­Ø© Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù†Øª Ø´Ø§Ø´Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ÙØªÙˆØ­Ø©
        renderer.render();
    }

    // ÙˆØ¸ÙŠÙØ© Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø© (Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£Ùˆ Ø§Ù„ÙÙˆØ²)
    function startNewGame(resume = false) {
        document.getElementById('setup-modal').classList.remove('active');
        document.getElementById('win-modal').classList.remove('active');
        document.getElementById('tooltip-modal').classList.remove('active'); // Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªÙ„Ù…ÙŠØ­

        if (resume) {
            try {
                const state = JSON.parse(localStorage.getItem('ludoState'));
                if (state) {
                    // ÙŠØ¬Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù„Ù€ setupGame Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
                    const playerConfigs = state.players.map(p => ({
                        type: p.type,
                        aiLevel: p.aiLevel
                    }));
                    game.setupGame(playerConfigs); // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† (Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù†Ø§Øª Token)
                    game.loadGame(state); // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„Ø©
                    renderer.render();
                    return;
                }
            } catch(e) {
                console.error("Failed to load game state:", e);
                localStorage.removeItem('ludoState');
            }
        }

        // Ø¨Ø¯Ø¡ Ø¬Ø¯ÙŠØ¯
        const count = parseInt(playerCountSelect.value);
        const playerConfigs = [];
        for (let i = 0; i < count; i++) {
            const type = document.getElementById(`player-type-${i}`).value;
            const level = document.getElementById(`ai-level-${i}`).value;
            playerConfigs.push({ type, aiLevel: level });
        }

        game.setupGame(playerConfigs);
    }

    // Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    document.getElementById('start-new-game').addEventListener('click', () => startNewGame(false));
    document.getElementById('resume-game').addEventListener('click', () => startNewGame(true));
    document.getElementById('roll-dice-button').addEventListener('click', () => game.rollDice());
    document.getElementById('setting-button').addEventListener('click', () => {
        document.getElementById('setup-modal').classList.add('active');
    });
    document.getElementById('mute-button').addEventListener('click', () => game.sm.toggleMute());
    document.getElementById('new-game-from-win').addEventListener('click', () => {
        document.getElementById('win-modal').classList.remove('active');
        document.getElementById('setup-modal').classList.add('active');
    });
    document.getElementById('share-screenshot').addEventListener('click', () => {
        const dataURL = CANVAS.toDataURL('image/png');
        const w = window.open('about:blank', '_blank');
        w.document.write('<img src="' + dataURL + '" style="max-width:100%; height:auto;">');
    });

    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ø¨Ø¹Ø¯ Ø¨Ø¶Ø¹ Ø«ÙˆØ§Ù†Ù
    setTimeout(() => {
        document.getElementById('tooltip-modal').classList.remove('active');
    }, 5000);

</script>
</body>
</html>

