<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Retro Platforms ‚Äî Hybrid Levels</title>
<style>
:root{
  --sky:#87ceeb; --ground:#6b4f2a; --ground-top:#8f6b3a;
  --player:#3498db; --enemy:#e67e22; --turtle:#16a085; --flier:#9b59b6; --shooter:#e74c3c;
  --spike:#c0392b; --goal:#2ecc71; --spring:#5dade2; --water:#3aa6ffcc;
  --ui:#000000cc; --text:#fff;
}
html,body{margin:0;background:#0d1117;color:var(--text);font-family:system-ui,Segoe UI,Roboto}
#game{display:block;margin:0 auto;background:var(--sky);image-rendering:pixelated;outline:none}
.topbar{position:fixed;top:8px;left:8px;right:8px;display:flex;gap:8px;align-items:center;z-index:5}
.panel{background:var(--ui);padding:8px 12px;border-radius:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grow{flex:1}
.btn{appearance:none;border:0;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
.btn.primary{background:#2ecc71;color:#062}
.btn.ghost{background:#ffffff10;color:#fff;border:1px solid #ffffff33}
.centered{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(2px);background:#0008;z-index:10}
.touch{position:fixed;bottom:16px;left:16px;right:16px;display:flex;justify-content:space-between;gap:16px;pointer-events:none;z-index:4}
.pad{display:flex;gap:16px}
.tbtn{width:84px;height:84px;border-radius:50%;background:#ffffff22;border:2px solid #ffffff55;pointer-events:auto;touch-action:none;user-select:none;backdrop-filter:blur(6px);color:#fff;font-size:22px;font-weight:800}
@media (min-width:900px){.touch{display:none}}
.hearts{letter-spacing:2px}
.hint{opacity:.8;font-size:12px;margin-top:6px}
.badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#ffffff22;border:1px solid #ffffff33}
.splash{width:min(900px,92vw);max-width:92vw;border-radius:16px;overflow:hidden;box-shadow:0 20px 60px #000a}
.splash-head{position:relative;height:min(340px,48vh);background:
  radial-gradient(1000px 280px at 20% 0%, #6ec5ff33 0%, transparent 60%),
  radial-gradient(800px 260px at 90% 10%, #e0a3ff33 0%, transparent 55%),
  linear-gradient(180deg,#223 0%,#112 100%);display:flex;align-items:center;justify-content:center}
.splash-canvas{position:absolute;inset:0}
.splash-title{position:relative;z-index:2;font-size:clamp(24px,5.2vw,44px);font-weight:900;letter-spacing:1px;color:#e8f7ff;text-shadow:0 2px 0 #0008,0 0 24px #69d1ff77}
.splash-body{background:#0b0f18;padding:14px}
</style>
</head>
<body>
  <div class="topbar">
    <div class="panel grow" id="hudLeft">
      <span id="hearts" class="hearts">‚ù§‚ù§‚ù§</span>
      <span id="shield" class="hint">üõ° 0</span>
      <span id="stage" class="badge">L1</span>
    </div>
    <div class="panel" id="hudRight">
      <button class="btn ghost" id="btnLang">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</button>
      <button class="btn ghost" id="btnMusic">üîá</button>
      <button class="btn ghost" id="btnPause">‚è∏Ô∏é</button>
    </div>
  </div>

  <canvas id="game" width="960" height="540" tabindex="0" aria-label="Game canvas"></canvas>

  <div class="touch" id="touch">
    <div class="pad">
      <button class="tbtn" id="btnLeft">‚óÄ</button>
      <button class="tbtn" id="btnRight">‚ñ∂</button>
    </div>
    <div class="pad">
      <button class="tbtn" id="btnJump">‚§ä</button>
      <button class="tbtn" id="btnShoot">‚úπ</button>
    </div>
  </div>

  <template id="tplOverlay">
    <div class="centered" id="overlay">
      <div class="panel" style="min-width:min(720px,94vw);text-align:center;max-height:90vh;overflow:auto">
        <div id="ovTitle" style="font-size:24px;font-weight:900;margin-bottom:8px">‚Äî</div>
        <div id="ovBody" style="line-height:1.6;margin-bottom:12px">‚Äî</div>
        <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap" id="ovButtons"></div>
        <div class="hint" id="ovHint">‚Üê ‚Üí move, Space/W jump, F shoot, Esc pause</div>
      </div>
    </div>
  </template>

<script>
(()=>{'use strict';

/* ================= I18N ================= */
const I18N={
  ar:{title:'ŸÖŸÜÿµÿßÿ™ ÿ•ÿ¨ÿ±ÿßÿ¶Ÿäÿ© ŸÖÿ™ÿØÿ±ÿ¨ÿ©',desc:'ÿ®ÿØÿßŸäÿ© Ÿàÿßÿ∂ÿ≠ÿ© Ÿàÿ≥ŸáŸÑÿ© ÿ´ŸÖ ÿ™ÿ∂ÿßÿ±Ÿäÿ≥ ÿ∑ÿ®ŸäÿπŸäÿ© ÿ®ŸÖŸÜÿ≠ÿØÿ±ÿßÿ™ ÿ™ÿØÿ±Ÿäÿ¨Ÿäÿ©ÿå ÿ≠ŸÅÿ± ŸàŸÖŸäÿßŸá Ÿàÿ£ÿ¥ŸàÿßŸÉ. ÿ™ÿ®ÿØÿ£ ŸàŸÖÿπŸÉ ÿ≥ŸÑÿßÿ≠. ÿßŸÇÿ™ŸÑ ÿßŸÑÿ£ÿπÿØÿßÿ° ŸÑÿ™ÿ≠ÿµŸÑ ÿπŸÑŸâ ÿ™ÿπÿ≤Ÿäÿ≤ÿßÿ™ (ÿ≥ÿ±ÿπÿ©/ŸÇŸÅÿ≤) ŸàŸÇŸÑŸàÿ® ŸàÿØÿ±Ÿàÿπ. ÿ£ŸàŸÑ 5 ŸÖÿ±ÿßÿ≠ŸÑ ŸÖÿ®ÿ±ŸÖÿ¨ÿ© ŸàÿßŸÑÿ®ŸÇŸäÿ© ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ JSON. ÿ≠ŸÅÿ∏ ÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÖÿπ ÿ•ÿπÿßÿØÿ© ŸÜŸÅÿ≥ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿπŸÜÿØ ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©.',
      start:'ÿßÿ®ÿØÿ£ ŸÑÿπÿ®ÿ© ÿ¨ÿØŸäÿØÿ©', cont:'ŸÖÿ™ÿßÿ®ÿπÿ©', paused:'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™', resume:'ŸÖÿ™ÿßÿ®ÿπÿ©', restart:'ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©', menu:'ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©',
      lose:'ÿÆÿ≥ÿ±ÿ™', stage:n=>`ŸÖÿ±ÿ≠ŸÑÿ© ${n}`, hint:'ŸÉŸäÿ®Ÿàÿ±ÿØ: ‚Üê ‚Üí ŸÑŸÑÿ≠ÿ±ŸÉÿ©ÿå Space/W ŸÑŸÑŸÇŸÅÿ≤ÿå F ŸÑŸÑÿ•ÿ∑ŸÑÿßŸÇÿå Esc ŸÑŸÑÿ•ŸäŸÇÿßŸÅ',
      drops:'ÿßŸÑÿ™ÿπÿ≤Ÿäÿ≤ÿßÿ™: ‚ù§ ŸÇŸÑÿ® | üõ° ÿØÿ±ÿπ | ‚á• ÿ≥ÿ±ÿπÿ© | ‚§ä ŸÇŸÅÿ≤'},
  en:{title:'Hybrid Procedural Platforms',desc:'Clear, easy start then natural terrain with gentle slopes, pits, water, spikes. Start with a gun. Defeat enemies for boosts (speed/jump), hearts, shields. First 5 levels are built-in, rest are loaded from JSON files. Auto-save; restart same level on death.',
      start:'Start New', cont:'Continue', paused:'Paused', resume:'Resume', restart:'Restart', menu:'Main Menu',
      lose:'You Lost', stage:n=>`Level ${n}`, hint:'Keyboard: ‚Üê ‚Üí move, Space/W jump, F shoot, Esc pause',
      drops:'Boosts: ‚ù§ Heart | üõ° Shield | ‚á• Speed | ‚§ä Jump'}
};
let lang='ar'; const T=(k,...a)=> typeof I18N[lang][k]==='function'?I18N[lang][k](...a):I18N[lang][k];

/* ================ CONFIG & RUNTIME ================ */
const CFG={
  viewW:960, viewH:540, tile:32,
  gravity:0.6, moveAcc:0.8, maxDX:5.2, maxDY:18, friction:0.86, jumpV:12.2,
  coyoteTime:0.09, jumpBuffer:0.12, variableJumpCut:0.45, cameraLerp:0.12,
  springV:16,
  enemy:{walkerSpeed:1.1,turtleSpeed:0.95,flierSpeed:1.25,shooterSpeed:0.75,bulletSpeed:3.2,fireRate:2.6},
  player:{maxHearts:6,shootCooldown:0.28,bulletSpeed:6.6},
  scaling:{bandSize:5, enemySpeedMul:1.07, enemyFireRateMul:0.96, enemyBulletSpeedMul:1.06, playerSpeedMul:1.05, playerJumpMul:1.04, playerBulletSpeedMul:1.04},
  vibration:true,
  // ÿ•ÿ∂ÿßŸÅÿ© ÿπÿØÿØ ÿßŸÑŸÖÿ±ÿßÿ≠ŸÑ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ÿßŸÑŸÖÿ®ÿ±ŸÖÿ¨ÿ©
  basicLevelCount: 5,
  jsonFiles: ['sentences1.json', 'sentences2.json', 'sentences3.json', 'sentences4.json']
};
const runtime={enemy:{...CFG.enemy}, player:{maxDX:CFG.maxDX,jumpV:CFG.jumpV,bulletSpeed:CFG.player.bulletSpeed}};

/* ================ DOM & HUD ================ */
const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
const tplOverlay=document.getElementById('tplOverlay');
const HUD={
  hearts:document.getElementById('hearts'), shield:document.getElementById('shield'), stage:document.getElementById('stage'),
  btnPause:document.getElementById('btnPause'), btnLang:document.getElementById('btnLang'), btnMusic:document.getElementById('btnMusic')
};
const TOUCH={ left:document.getElementById('btnLeft'), right:document.getElementById('btnRight'), jump:document.getElementById('btnJump'), shoot:document.getElementById('btnShoot') };

/* ================ UTILS ================ */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const rects=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
const vibrate=ms=>{ if(CFG.vibration&&navigator.vibrate) navigator.vibrate(ms); };
const nowSec=()=>performance.now()/1000;
function rnd(seed){ return (Math.sin(seed*12.9898)*43758.5453)%1; }

/* ================ AUDIO (Modified) ================ */
let audioCtx=null, muted=true; // ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ muted ÿπŸÑŸâ true ÿ®ÿ¥ŸÉŸÑ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑÿ™ŸàÿßŸÅŸÇ ŸÖÿπ ÿ•ÿ≤ÿßŸÑÿ© BGM

function ensureAudio(){ if(!audioCtx){ try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch{} } }
function sfx(type='sine',f=440,dur=0.08,g=0.07){ if(muted) return; ensureAudio(); if(!audioCtx) return;
  const t0=audioCtx.currentTime,o=audioCtx.createOscillator(),ga=audioCtx.createGain();
  o.type=type; o.frequency.value=f; ga.gain.value=g; ga.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
  o.connect(ga).connect(audioCtx.destination); o.start(t0); o.stop(t0+dur);
}
// ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ© ÿπŸÑŸâ ÿßŸÑŸÖÿ§ÿ´ÿ±ÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
const SFX={ jump:()=>sfx('square',520,0.09,0.08), pick:()=>sfx('triangle',900,0.08,0.06), hit:()=>sfx('sawtooth',180,0.12,0.07),
  win:()=>{ sfx('square',660,0.16,0.08); setTimeout(()=>sfx('square',880,0.13,0.06),120); }, spring:()=>sfx('triangle',720,0.1,0.07), shoot:()=>sfx('square',720,0.06,0.06) };

// ÿ≠ÿ∞ŸÅ ÿØŸàÿßŸÑ startBGM() Ÿà stopBGM() ÿ®ÿßŸÑŸÉÿßŸÖŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿ∑ŸÑÿ®

/* ================ INPUT ================ */
const keys={left:false,right:false,jump:false,shoot:false};
function wantFocus(){ ensureAudio(); /* startBGM(); */ canvas.focus(); } // ÿ™ŸÖ ÿ≠ÿ∞ŸÅ startBGM
addEventListener('keydown',e=>{
  if(['ArrowLeft','KeyA'].includes(e.code)) keys.left=true;
  if(['ArrowRight','KeyD'].includes(e.code)) keys.right=true;
  if(['Space','KeyW'].includes(e.code)){ keys.jump=true; wantFocus(); }
  if(e.code==='KeyF'){ keys.shoot=true; wantFocus(); }
  if(e.code==='Escape') togglePause();
});
addEventListener('keyup',e=>{
  if(['ArrowLeft','KeyA'].includes(e.code)) keys.left=false;
  if(['ArrowRight','KeyD'].includes(e.code)) keys.right=false;
  if(['Space','KeyW'].includes(e.code)) keys.jump=false;
  if(e.code==='KeyF') keys.shoot=false;
});
['left','right','jump','shoot'].forEach(k=>{
  const b=TOUCH[k];
  b.addEventListener('pointerdown',e=>{ e.preventDefault(); keys[k]=true; vibrate(15); wantFocus(); });
  ['pointerup','pointerleave','pointercancel'].forEach(ev=> b.addEventListener(ev,e=>{ e.preventDefault(); keys[k]=false; }));
});
// ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿπÿßŸÑÿ¨ ÿ≤ÿ± ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸÑŸäÿπŸÉÿ≥ ÿßŸÑÿ•ÿ≤ÿßŸÑÿ©
HUD.btnMusic.textContent='üîá';
HUD.btnMusic.addEventListener('click',()=>{ muted=!muted; HUD.btnMusic.textContent=muted?'üîá':'üîä'; /* if(muted) stopBGM(); else startBGM(); */ });
HUD.btnLang.addEventListener('click',()=>{ lang=(lang==='ar'?'en':'ar'); document.documentElement.lang=lang; document.documentElement.dir=(lang==='ar'?'rtl':'ltr'); HUD.btnLang.textContent=(lang==='ar'?'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©':'English'); updateHUD(); if(state.scene==='menu') startMenu(); if(state.scene==='pause'){ hideOverlay(); togglePause(); } });
HUD.btnPause.addEventListener('click',()=>togglePause());
addEventListener('pointerdown',onceKick,{once:true}); addEventListener('keydown',onceKick,{once:true});
function onceKick(){ wantFocus(); }

/* ================ WORLD & STATE ================ */
const TILE={EMPTY:0,SOLID:1,SPIKE:2,SPRING:3,GOAL:4,WATER:5,MOVING:6};
const ENEMY={WALKER:0,TURTLE:1,FLIER:2,SHOOTER:3};
const SAVEKEY='retro_procedural_v4_hybrid'; // ÿ™ÿ∫ŸäŸäÿ± ŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑÿ≠ŸÅÿ∏ ŸÑÿ™ÿ¨ŸÜÿ® ÿ™ÿπÿßÿ±ÿ∂ÿßÿ™

const state={scene:'menu', level:0, band:0, camX:0, camY:0, hearts:3, shield:0, hasGun:true, overlayEl:null, lastShotAt:-999, boosts:{speed:0,jump:0}};
const player={x:0,y:0,w:24,h:30,dx:0,dy:0,on:false,coyote:0,jumpBuf:0,inv:0,facing:1};
let enemies=[], eBullets=[], pBullets=[], movingPlatforms=[], drops=[], currentLevelData=null; // ÿ•ÿ∂ÿßŸÅÿ© currentLevelData ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©

/* ================ SAVE/LOAD ================ */
function saveProgress(){ try{
  localStorage.setItem(SAVEKEY, JSON.stringify({
    level: state.level, hearts: state.hearts, shield: state.shield,
    boosts: state.boosts, lang
  }));
}catch{}}
function loadProgress(){ try{
  const s=JSON.parse(localStorage.getItem(SAVEKEY)||'null'); if(!s) return false;
  state.level=Number.isFinite(s.level)?s.level:0; state.hearts=s.hearts||3; state.shield=s.shield||0; state.boosts=s.boosts||{speed:0,jump:0};
  lang=s.lang||lang; document.documentElement.lang=lang; document.documentElement.dir=(lang==='ar'?'rtl':'ltr'); HUD.btnLang.textContent=(lang==='ar'?'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©':'English');
  return true;
}catch{ return false; }}

/* ================ LEVEL GENERATION: BASIC 5 LEVELS ================= */

// ÿØÿßŸÑÿ© ŸÖÿ®ÿ≥ÿ∑ÿ© ŸÑÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÖÿ±ÿßÿ≠ŸÑ ÿßŸÑÿÆŸÖÿ≥ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
function makeBasicLevel(levelIndex) {
    const H=20, W=120 + levelIndex*8;
    const map=Array.from({length:H},()=>Array(W).fill(TILE.EMPTY));
    const baseY=H-3;

    // ÿßŸÑÿ£ÿ±ÿ∂Ÿäÿ©
    for(let x=0;x<W;x++){
        let y = baseY;
        if(levelIndex >= 1 && x>20 && x<W-20) y += Math.floor(Math.sin(x*0.5/(4+levelIndex))*1.5);
        if(levelIndex >= 3 && x>50 && x<W-50 && Math.random()<0.02) y = H-1; // ÿ≠ŸÅÿ±ÿ© ÿ®ÿ≥Ÿäÿ∑ÿ©
        for(let py=y;py<H;py++) map[py][x]=TILE.SOLID;
    }

    // ÿßŸÑŸÖŸÜÿµÿßÿ™ ÿßŸÑÿπÿßÿ¶ŸÖÿ© (ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 1)
    const moving = [];
    if(levelIndex >= 1){
        for(let m=0;m<1+levelIndex;m++){
            const mx= 22 + m*Math.floor(W/(2+levelIndex));
            const yTop= Math.max(3, baseY-3-m);
            map[Math.floor(yTop/CFG.tile)][mx]=TILE.MOVING; // ŸÑÿß ŸÜÿ≥ÿ™ÿÆÿØŸÖ TILE.MOVING ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÅŸä makeBasicLevel
            moving.push({x:mx*CFG.tile,y:yTop*CFG.tile,w:CFG.tile*2,h:CFG.tile/2,t:0,dir:(m%2?1:-1),range:CFG.tile*2});
        }
    }

    // ÿßŸÑÿ£ÿπÿØÿßÿ°
    const enemies = [];
    if(levelIndex >= 1){
        const enemyCount = 1 + levelIndex*2;
        for(let i=0;i<enemyCount;i++){
            const bx=20+i*Math.floor((W-40)/enemyCount);
            const ex=Math.min(W-8,bx+10);
            const yTop = map.length;
            for(let y=0;y<H;y++) if(map[y][bx]===TILE.SOLID){ yTop=y; break; }
            const type = (i+levelIndex)%4;
            const base={x:bx*CFG.tile,y:(yTop-1)*CFG.tile,w:28,h:28,minX:bx*CFG.tile,maxX:ex*CFG.tile,dir:(i%2?1:-1)};
            if(type===0) enemies.push({...base,type:ENEMY.WALKER});
            else if(type===1 && levelIndex>=2) enemies.push({...base,type:ENEMY.TURTLE});
            else if(type===2 && levelIndex>=3) enemies.push({...base,type:ENEMY.FLIER,y:(Math.max(3,yTop-6))*CFG.tile,w:28,h:22});
            else if(type===3 && levelIndex>=4) enemies.push({...base,type:ENEMY.SHOOTER,cool:Math.random()*CFG.enemy.fireRate});
        }
    }


    // ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ®ÿØÿßŸäÿ© ŸàÿßŸÑŸÜŸáÿßŸäÿ©
    const sx=3, sy=H-4;
    const gx=W-4, gyEnd=H-3;
    for(let y=gyEnd-4;y<=gyEnd-1;y++) if(y>=0) map[y][gx]=TILE.GOAL;

    return {W,H,map,start:{x:sx*CFG.tile,y:Math.max(0,sy)*CFG.tile},enemies,moving};
}

/* ================ LEVEL GENERATION: JSON LEVELS ================= */

const JSON_LEVEL_CACHE = {};
let JSON_LOAD_PROMISE = null;

// ÿØÿßŸÑÿ© ŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸÖŸÑŸÅ JSON ŸÖÿπŸäŸÜ
function fetchJsonLevel(index) {
    const fileName = CFG.jsonFiles[(index - CFG.basicLevelCount) % CFG.jsonFiles.length];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™
    if (JSON_LEVEL_CACHE[fileName]) {
        return Promise.resolve(JSON_LEVEL_CACHE[fileName]);
    }
    
    // ŸÖŸÜÿπ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ™ÿπÿØÿØ ŸÑŸÜŸÅÿ≥ ÿßŸÑŸÖŸÑŸÅ ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑŸàŸÇÿ™
    if (JSON_LOAD_PROMISE) {
        return JSON_LOAD_PROMISE;
    }

    JSON_LOAD_PROMISE = fetch(fileName)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to load ${fileName}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ Ÿàÿ®ÿπÿ∂ ÿßŸÑÿ™ÿπÿØŸäŸÑÿßÿ™ ÿßŸÑÿ∂ÿ±Ÿàÿ±Ÿäÿ©
            data.W = data.map[0].length;
            data.H = data.map.length;
            JSON_LEVEL_CACHE[fileName] = data;
            JSON_LOAD_PROMISE = null; // ÿ•ŸÜŸáÿßÿ° ŸàÿπÿØ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
            return data;
        })
        .catch(error => {
            console.error(error);
            JSON_LOAD_PROMISE = null;
            // ŸÅŸä ÿ≠ÿßŸÑÿ© ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑÿå ŸÜÿ±ÿ¨ÿπ ŸÖÿ≥ÿ™ŸàŸâ ÿ£ÿ≥ÿßÿ≥Ÿä ÿ®ÿ≥Ÿäÿ∑ ŸÉÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä
            return makeBasicLevel(CFG.basicLevelCount - 1);
        });
        
    return JSON_LOAD_PROMISE;
}


/* On-demand cache & Level Gateway */
const LEVELS = new Proxy({ store: {} }, {
    get(t, k) {
        const i = Number(k);
        if (Number.isNaN(i) || i < 0) return undefined;
        
        // ÿßŸÑŸÖÿ±ÿßÿ≠ŸÑ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© (0 ÿ•ŸÑŸâ 4)
        if (i < CFG.basicLevelCount) {
            if (!t.store[i]) t.store[i] = makeBasicLevel(i);
            return t.store[i];
        }
        
        // ÿßŸÑŸÖÿ±ÿßÿ≠ŸÑ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© (5 ŸÅŸÖÿß ŸÅŸàŸÇ)
        if (!t.store[i]) {
            // ŸÜÿ∂ÿπ ŸàÿπÿØ (Promise) ŸÖÿ§ŸÇÿ™Ÿãÿß ŸÑÿ™ÿ¨ŸÜÿ® ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑŸÑÿßŸÜŸáÿßÿ¶Ÿäÿ© ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
            t.store[i] = {W: 960/CFG.tile, H: 540/CFG.tile, map:[], enemies:[], moving:[], isAsync: true}; 
            fetchJsonLevel(i)
                .then(data => {
                    t.store[i] = data; // ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© ÿ®ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ŸÖŸÑÿ©
                })
                .catch(err => {
                    console.error("Error loading JSON level, using fallback:", err);
                    t.store[i] = makeBasicLevel(CFG.basicLevelCount - 1); // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿ≥ÿ™ŸàŸâ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä
                });
        }
        
        return t.store[i];
    }
});


/* ================ OVERLAYS ================ */
function showOverlay(title, bodyHTML, buttons){
  hideOverlay();
  const frag=tplOverlay.content.cloneNode(true);
  frag.querySelector('#ovTitle').textContent=title;
  frag.querySelector('#ovBody').innerHTML=bodyHTML;
  frag.querySelector('#ovHint').textContent=T('hint');
  const box=frag.querySelector('#ovButtons');
  (buttons||[]).forEach(b=>{ const el=document.createElement('button'); el.className='btn '+(b.primary?'primary':'ghost'); el.textContent=b.label; el.addEventListener('click',b.on); box.appendChild(el); });
  document.body.appendChild(frag); state.overlayEl=document.getElementById('overlay');
}
function hideOverlay(){ if(state.overlayEl){ state.overlayEl.remove(); state.overlayEl=null; } }
function splashHTML(){ return `
  <div class="splash">
    <div class="splash-head"><canvas class="splash-canvas" id="splashCanvas"></canvas><div class="splash-title">Retro Platforms</div></div>
    <div class="splash-body">${I18N[lang].desc}<div class="hint" style="margin-top:8px">${I18N[lang].drops}</div></div>
  </div>`;}
function renderSplash(){ const c=document.getElementById('splashCanvas'); if(!c) return;
  const r=c.parentElement.getBoundingClientRect(); c.width=r.width|0; c.height=r.height|0; const x=c.getContext('2d');
  x.fillStyle='#0e1422'; x.fillRect(0,0,c.width,c.height);
  x.fillStyle='#ffffffaa'; for(let i=0;i<100;i++) x.fillRect(Math.random()*c.width, Math.random()*c.height*0.6, 2, 2);
  const hill=(y,col)=>{ x.fillStyle=col; for(let i=-1;i<6;i++){ const bx=i*240; x.beginPath(); x.moveTo(bx,y+200); x.lineTo(bx+120,y+40); x.lineTo(bx+240,y+200); x.closePath(); x.fill(); } };
  hill(c.height*0.45,'#17304a'); hill(c.height*0.55,'#1c3a5a'); hill(c.height*0.65,'#204568');
  requestAnimationFrame(renderSplash);
}

/* ================ SCALING & FLOW ================ */
function applyScaling(levelIndex){
  const b=Math.floor(levelIndex/CFG.scaling.bandSize); 
  state.band=b;
  const eMul=Math.pow(CFG.scaling.enemySpeedMul,b), 
        eFire=Math.pow(CFG.scaling.enemyFireRateMul,b), 
        eBullet=Math.pow(CFG.scaling.enemyBulletSpeedMul,b);
  const pSpd=Math.pow(CFG.scaling.playerSpeedMul,b), 
        pJmp=Math.pow(CFG.scaling.playerJumpMul,b), 
        pBul=Math.pow(CFG.scaling.playerBulletSpeedMul,b);
  runtime.enemy.walkerSpeed=CFG.enemy.walkerSpeed*eMul;
  runtime.enemy.turtleSpeed=CFG.enemy.turtleSpeed*eMul;
  runtime.enemy.flierSpeed =CFG.enemy.flierSpeed *eMul;
  runtime.enemy.shooterSpeed=CFG.enemy.shooterSpeed*eMul;
  runtime.enemy.fireRate   =CFG.enemy.fireRate   *eFire;
  runtime.enemy.bulletSpeed=CFG.enemy.bulletSpeed*eBullet;
  runtime.player.maxDX=CFG.maxDX*pSpd;
  runtime.player.jumpV=CFG.jumpV*pJmp;
  runtime.player.bulletSpeed=CFG.player.bulletSpeed*pBul;
}

function resetRun(){ 
  state.hearts=3; 
  state.shield=0; 
  state.boosts={speed:0,jump:0}; 
  saveProgress(); 
}

function startMenu(){
  state.scene='menu'; 
  updateHUD();
  const hasSave=loadProgress();
  showOverlay(I18N[lang].title, splashHTML(), [
    {label:I18N[lang].start, primary:true, on:()=>{ hideOverlay(); resetRun(); startLevel(0,true); }},
   ...(has?[{label:I18N[lang].cont, on:()=>{ hideOverlay(); startLevel(state.level,true); }}]:[])
  ]);
  setTimeout(renderSplash,0);
}

function startLevel(i,reset=true){
  state.level=Math.max(0, i|0); 
  applyScaling(state.level);
  
  const L=LEVELS[state.level];
  if (L.isAsync) {
    // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿ™ÿ≠ŸÖŸÑÿå ŸÜŸÜÿ™ÿ∏ÿ± ÿ≠ÿ™Ÿâ ÿ™ŸÉÿ™ŸÖŸÑ
    state.scene='loading';
    updateHUD();
    showOverlay(T('stage',state.level+1),'ÿ¨ÿßÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©...','');
    // ŸÜÿ≥ÿ™ÿÆÿØŸÖ setImmediate ÿ£Ÿà setTimeout(0) ŸÉÿ®ÿØŸäŸÑ ŸÑŸÄ requestAnimationFrame
    setTimeout(() => startLevel(i, reset), 100); 
    return;
  }
  
  hideOverlay();
  currentLevelData = L;
  enemies=JSON.parse(JSON.stringify(L.enemies)); 
  enemies.forEach(e=>e._dead=false);
  movingPlatforms=JSON.parse(JSON.stringify(L.moving));
  drops.length=0; eBullets.length=0; pBullets.length=0;
  if(reset) Object.assign(player,{x:L.start.x,y:L.start.y,dx:0,dy:0,on:false,coyote:0,jumpBuf:0,inv:0,facing:1});
  state.camX=player.x+player.w/2 - canvas.width/2;
  state.camY=player.y+player.h/2 - canvas.height/2;
  state.scene='playing'; 
  updateHUD(); 
  saveProgress(); 
  wantFocus();
}

function finishLevel(){
  SFX.win(); 
  saveProgress();
  // ÿ™ÿπÿØŸäŸÑ: ÿ∂ŸÖÿßŸÜ ÿßŸÑÿ™ŸÇÿØŸÖ ÿßŸÑÿ≥ŸÑŸäŸÖ ŸÑŸÑŸÖÿ±ÿ≠ŸÑÿ© ŸÑŸÖŸÜÿπ ÿßŸÑŸÇŸÅÿ≤.
  state.level++; 
  setTimeout(()=>{ startLevel(state.level, true); }, 1000); 
}

function gameOver(){
  SFX.hit();
  const lvl=state.level;
  showOverlay(I18N[lang].lose, '', [
    {label:I18N[lang].restart+' ‚Ü∫', primary:true, on:()=>{ hideOverlay(); state.level=lvl; startLevel(state.level,true); }},
    {label:I18N[lang].menu+' ‚åÇ', on:()=>{ hideOverlay(); startMenu(); }}
  ]);
  state.scene='menu';
}

function togglePause(){
  if(state.scene==='playing'){
    state.scene='pause';
    showOverlay(I18N[lang].paused,'',[
      {label:I18N[lang].resume+' ‚ñ∂', primary:true, on:()=>{ hideOverlay(); state.scene='playing'; }},
      {label:I18N[lang].restart+' ‚Ü∫', on:()=>{ hideOverlay(); startLevel(state.level,true); }},
      {label:I18N[lang].menu+' ‚åÇ', on:()=>{ hideOverlay(); startMenu(); }},
      {label: muted?'üîä Music':'üîá Music', on:()=>{ muted=!muted; HUD.btnMusic.textContent=muted?'üîá':'üîä'; hideOverlay(); togglePause(); }}, // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≤ÿ±
      {label:(lang==='ar'?'English':'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©'), on:()=>{ lang=(lang==='ar'?'en':'ar'); document.documentElement.lang=lang; document.documentElement.dir=(lang==='ar'?'rtl':'ltr'); HUD.btnLang.textContent=(lang==='ar'?'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©':'English'); updateHUD(); hideOverlay(); togglePause(); }}
    ]);
  }else if(state.scene==='pause'){ 
    hideOverlay(); 
    state.scene='playing'; 
  }
}

/* ================ DROPS ================= */
function spawnDrop(x,y){
  const r=Math.random(); 
  const type=r<0.25?'heart': r<0.5?'shield': r<0.75?'speed':'jump';
  drops.push({x:x-9,y:y-6,w:18,h:18,type,ttl:5});
}
function updateDrops(dt){
  for(let i=drops.length-1;i>=0;i--){
    const d=drops[i]; 
    d.ttl-=dt;
    if(rects(player,d)){
      if(d.type==='heart' && state.hearts<CFG.player.maxHearts) state.hearts++;
      else if(d.type==='shield') state.shield=Math.min(9,state.shield+1);
      else if(d.type==='speed') state.boosts.speed=Math.min(5,state.boosts.speed+1);
      else if(d.type==='jump') state.boosts.jump=Math.min(5,state.boosts.jump+1);
      SFX.pick(); 
      vibrate(20); 
      updateHUD(); 
      drops.splice(i,1); 
      saveProgress();
    }else if(d.ttl<=0) drops.splice(i,1);
  }
}
function drawDrops(){
  drops.forEach(d=>{
    const x=d.x-state.camX,y=d.y-state.camY;
    const g=ctx.createRadialGradient(x+d.w/2,y+d.h/2,2,x+d.w/2,y+d.h/2,18); g.addColorStop(0,'#ffffff88'); g.addColorStop(1,'#ffffff00');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x+d.w/2,y+d.h/2,18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle= d.type==='heart'?'#e74c3c': d.type==='shield'?'#3498db': d.type==='speed'?'#f1c40f':'#2ecc71';
    if(d.type==='heart'){ ctx.beginPath(); ctx.moveTo(x+9,y+6); ctx.bezierCurveTo(x+2,y+0,x,y+10,x+9,y+14); ctx.bezierCurveTo(x+18,y+10,x+16,y+0,x+9,y+6); ctx.fill(); }
    else if(d.type==='shield'){ ctx.fillRect(x+4,y+5,10,10); ctx.fillRect(x+6,y+15,6,2); }
    else if(d.type==='speed'){ ctx.fillRect(x+4,y+10,12,4); ctx.fillRect(x+10,y+6,4,4); }
    else { ctx.fillRect(x+7,y+4,4,10); ctx.fillRect(x+4,y+10,10,4); }
  });
}

/* ================ MECHANICS ================ */
function shoot(){
  const t=nowSec(); 
  if(t-state.lastShotAt<CFG.player.shootCooldown) return; 
  state.lastShotAt=t; 
  SFX.shoot();
  const dir=player.facing; 
  pBullets.push({x:player.x+player.w/2,y:player.y+player.h/2,w:10,h:6,dx:dir*runtime.player.bulletSpeed,dy:0});
}
function defeatEnemy(e){
  if(e._dead) return;
  spawnDrop(e.x+e.w/2, e.y);
  const proto={minX:e.minX,maxX:e.maxX,y:e.y,w:e.w,h:e.h,type:e.type};
  e._dead=true;
  setTimeout(()=>{ Object.assign(e,{...proto,x:proto.minX,dir:1,_dead:false,cool:Math.random()*runtime.enemy.fireRate}); },3000);
}
function hurtPlayer(){
  if(player.inv>0) return;
  if(state.shield>0){ 
    state.shield--; 
    player.inv=1.0; 
    SFX.hit(); 
    vibrate(40); 
    updateHUD(); 
    saveProgress(); 
    return; 
  }
  state.hearts--; 
  player.inv=1.0; 
  SFX.hit(); 
  vibrate(60); 
  updateHUD(); 
  saveProgress();
  if(state.hearts<=0){ gameOver(); return; }
  const L=currentLevelData; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÖÿ≠ŸÖŸÑÿ©
  Object.assign(player,{x:L.start.x,y:L.start.y,dx:0,dy:0,on:false});
}

/* ================ PHYSICS ================= */
function tileAt(px,py){
  const L=currentLevelData; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÖÿ≠ŸÖŸÑÿ©
  if (!L || L.isAsync) return TILE.SOLID; // ŸÖŸÜÿπ ÿßŸÑŸÖÿ¥ÿßŸÉŸÑ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
  const tx=(px/CFG.tile)|0, ty=(py/CFG.tile)|0;
  if(tx<0||ty<0||tx>=L.W||ty>=L.H) return TILE.SOLID;
  return L.map[ty][tx];
}

function moveAndCollide(ent){
  ent.x+=ent.dx;
  if(ent.dx!==0){
    const s=Math.sign(ent.dx), cx=ent.x+(s>0?ent.w:0);
    const pts=[{x:cx,y:ent.y+2},{x:cx,y:ent.y+ent.h-2}];
    for(const p of pts){
      const t=tileAt(p.x,p.y);
      if(t===TILE.SOLID){
        const tx=(p.x/CFG.tile)|0;
        ent.x=tx*CFG.tile - (s>0?ent.w:-CFG.tile);
        ent.dx=0;
        break;
      }
    }
  }
  ent.y+=ent.dy; ent.on=false;
  const vy=ent.y+(ent.dy>0?ent.h:0),
        pts2=[{x:ent.x+2,y:vy},{x:ent.x+ent.w-2,y:vy}];
  for(const p of pts2){
    const t=tileAt(p.x,p.y);
    if(t===TILE.SOLID||t===TILE.MOVING){
      const ty=(p.y/CFG.tile)|0;
      ent.y=ty*CFG.tile - (ent.dy>0?ent.h:-CFG.tile);
      if(ent.dy>0) ent.on=true;
      ent.dy=0;
      break;
    }
  }
  for(const mp of movingPlatforms){
    const r={x:mp.x,y:mp.y,w:mp.w,h:mp.h},
          feet={x:ent.x+2,y:ent.y+ent.h,w:ent.w-4,h:2};
    if(rects(feet,r)){
      ent.y=mp.y-ent.h;
      ent.on=true;
      ent.x+=(mp.x-(mp._px||mp.x));
    }
    mp._px=mp.x;
  }
}

function interactTiles(){
  const L=currentLevelData; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÖÿ≠ŸÖŸÑÿ©
  if (!L || L.isAsync) return;
  const feet={x:player.x+player.w/2,y:player.y+player.h-2};
  const t=tileAt(feet.x,feet.y);
  if(t===TILE.SPIKE){ hurtPlayer(); }
  if(t===TILE.SPRING){
    player.dy=-CFG.springV*(1+state.boosts.jump*0.1);
    player.on=false;
    SFX.spring();
  }
  if(t===TILE.WATER){
    state.hearts=0;
    updateHUD();
    saveProgress();
    gameOver();
    return;
  }
  const gx=(L.W-4)*CFG.tile,
        gyTop = groundTopAt(L.map,L.W-4);
  const goalBox={x:gx,y:(gyTop-4)*CFG.tile,w:CFG.tile,h:CFG.tile*4};
  if(rects(player,goalBox)) finishLevel();
}

function groundTopAt(map,x){
  for(let y=0;y<map.length;y++)
    if(map[y][x]===TILE.SOLID) return y;
  return map.length-2;
}

/* ================ UPDATE & DRAW ================ */
let last=performance.now();
function update(dt){
  if(state.scene!=='playing') return;

  const L = currentLevelData;
  if (!L || L.isAsync) return; // ŸÑÿß ÿ™ÿπŸÖŸÑ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ŸÑÿß ÿ™ÿ≤ÿßŸÑ ŸÇŸäÿØ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ

  movingPlatforms.forEach(mp=>{
    mp.t+=dt*mp.dir;
    const off=Math.sin(mp.t)*mp.range;
    mp.x+=(off-(mp._p||0));
    mp._p=off;
  });

  let acc=CFG.moveAcc*(1+state.boosts.speed*0.1),
      maxDX=runtime.player.maxDX*(1+state.boosts.speed*0.05),
      jumpV=runtime.player.jumpV*(1+state.boosts.jump*0.1);
  let ax=0;
  if(keys.left){ ax-=acc; player.facing=-1; }
  if(keys.right){ ax+=acc; player.facing=1; }
  player.dx=clamp(player.dx+ax, -maxDX, maxDX);
  if(player.on && ax===0) player.dx*=CFG.friction;
  player.dy=clamp(player.dy+CFG.gravity, -CFG.maxDY, CFG.maxDY);

  if(keys.jump) player.jumpBuf=CFG.jumpBuffer;
  else player.jumpBuf=Math.max(0,player.jumpBuf-dt);
  player.coyote = player.on? CFG.coyoteTime : Math.max(0,player.coyote-dt);
  if(player.jumpBuf>0 && player.coyote>0){
    player.dy=-jumpV;
    player.on=false;
    player.coyote=0;
    player.jumpBuf=0;
    SFX.jump();
    vibrate(20);
  }
  if(!keys.jump && player.dy<-2) player.dy*=CFG.variableJumpCut;

  moveAndCollide(player);

  const worldFloor=(L.H-2)*CFG.tile;
  if(player.y > worldFloor+8){
    state.hearts=0;
    updateHUD();
    saveProgress();
    gameOver();
    return;
  }

  interactTiles();

  if(state.hasGun && keys.shoot) shoot();

  enemies.forEach(e=>{
    if(e._dead) return;
    const sp = e.type===ENEMY.FLIER?runtime.enemy.flierSpeed :
               e.type===ENEMY.SHOOTER?runtime.enemy.shooterSpeed :
               e.type===ENEMY.TURTLE?runtime.enemy.turtleSpeed :
               runtime.enemy.walkerSpeed;
    e.x += e.dir * sp * dt * 60;
    if(e.x<e.minX){ e.x=e.minX; e.dir=1; }
    if(e.x+e.w>e.maxX){ e.x=e.maxX-e.w; e.dir=-1; }
    if(e.type===ENEMY.SHOOTER){
      e.cool=(e.cool||0)-dt;
      if(e.cool<=0){
        e.cool=runtime.enemy.fireRate;
        const dir=(player.x<e.x?-1:1);
        eBullets.push({x:e.x+(dir>0?e.w:0),y:e.y+10,w:10,h:10,dx:dir*runtime.enemy.bulletSpeed,dy:0});
      }
    }
    if(player.inv<=0 && rects(player,e)){
      const stomp = player.dy>0 && (player.y+player.h-e.y)<14;
      if(stomp && (e.type===ENEMY.WALKER||e.type===ENEMY.TURTLE)){
        player.dy=-(runtime.player.jumpV*0.8);
        SFX.hit();
        defeatEnemy(e);
      } else {
        hurtPlayer();
      }
    }
  });

  eBullets.forEach(b=>{ b.x+=b.dx; b.y+=b.dy; });
  eBullets=eBullets.filter(b=>{
    if(rects(player,b)){ hurtPlayer(); return false; }
    return onScreen(b,L);
  });
  pBullets.forEach(b=>{ b.x+=b.dx; b.y+=b.dy; });
  pBullets=pBullets.filter(b=>{
    let alive=true;
    for(const e of enemies){
      if(e._dead) continue;
      if(rects(b,{x:e.x,y:e.y,w:e.w,h:e.h})){
        SFX.hit();
        defeatEnemy(e);
        alive=false;
        break;
      }
    }
    return alive && onScreen(b,L);
  });

  updateDrops(dt);

  const targetX=clamp(player.x+player.w/2 - canvas.width/2, 0, L.W*CFG.tile - canvas.width);
  const targetY=clamp(player.y+player.h/2 - canvas.height*0.6, 0, L.H*CFG.tile-canvas.height);
  state.camX=lerp(state.camX,targetX,CFG.cameraLerp);
  state.camY=lerp(state.camY,targetY,CFG.cameraLerp);

  if(player.inv>0) player.inv=Math.max(0,player.inv-dt);
}
function onScreen(b,L){ return b.x>-64 && b.x<L.W*CFG.tile+64 && b.y>-64 && b.y<L.H*CFG.tile+64; }

function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
function drawParallax(offset, baseY, color){
  ctx.fillStyle=color; for(let i=-1;i<6;i++){ const x=((i*240-(offset%240))|0);
    ctx.beginPath(); ctx.moveTo(x,baseY+120); ctx.lineTo(x+120,baseY+40); ctx.lineTo(x+240,baseY+200); ctx.closePath(); ctx.fill();
  }
}
function draw(){
  ctx.fillStyle=getCSS('--sky'); ctx.fillRect(0,0,canvas.width,canvas.height);
  drawParallax(state.camX*0.5, 90-state.camY*0.5, '#b3e5fc');
  drawParallax(state.camX*0.8, 50-state.camY*0.8, '#d0f0ff');
  
  const L = currentLevelData;
  if (state.scene === 'playing' && L && !L.isAsync) {
    const T=CFG.tile; const sx=(state.camX/T)|0, ex=Math.ceil((state.camX+canvas.width)/T);
    for(let y=0;y<L.H;y++){
      for(let x=sx;x<Math.min(ex,L.W);x++){
        const t=L.map[y][x], px=x*T-state.camX, py=y*T-state.camY;
        if(t===TILE.SOLID){ ctx.fillStyle=getCSS('--ground'); ctx.fillRect(px,py,T,T); ctx.fillStyle=getCSS('--ground-top'); ctx.fillRect(px,py,T,6); }
        else if(t===TILE.SPIKE){ ctx.fillStyle=getCSS('--spike'); ctx.beginPath(); ctx.moveTo(px,py+T); ctx.lineTo(px+T/2,py); ctx.lineTo(px+T,py+T); ctx.closePath(); ctx.fill(); }
        else if(t===TILE.SPRING){ ctx.fillStyle=getCSS('--spring'); ctx.fillRect(px+6,py+T-10,T-12,10); ctx.fillStyle='#85c1e9'; ctx.fillRect(px+6,py+T-16,T-12,6); }
        else if(t===TILE.WATER){ ctx.fillStyle=getCSS('--water'); ctx.fillRect(px,py,T,T); ctx.fillStyle='#ffffff22'; ctx.fillRect(px,py+T-6,T,6); }
        else if(t===TILE.GOAL){ ctx.fillStyle='#fff'; ctx.fillRect(px+T/2-2,py,4,T*4); ctx.fillStyle=getCSS('--goal'); ctx.beginPath(); ctx.moveTo(px+T/2+2,py+6); ctx.lineTo(px+T/2+22,py+16); ctx.lineTo(px+T/2+2,py+26); ctx.closePath(); ctx.fill(); }
      }
    }
  }

  movingPlatforms.forEach(mp=>{ const x=mp.x-state.camX,y=mp.y-state.camY; ctx.fillStyle='#bdc3c7'; ctx.fillRect(x,y,mp.w,mp.h); ctx.fillStyle='#95a5a6'; ctx.fillRect(x,y,mp.w,4); });
  enemies.forEach(e=>{
    if(e._dead) return; const x=e.x-state.camX,y=e.y-state.camY;
    if(e.type===ENEMY.WALKER) ctx.fillStyle=getCSS('--enemy');
    else if(e.type===ENEMY.TURTLE) ctx.fillStyle=getCSS('--turtle');
    else if(e.type===ENEMY.FLIER) ctx.fillStyle=getCSS('--flier');
    else ctx.fillStyle=getCSS('--shooter');
    ctx.fillRect(x,y,e.w,e.h); ctx.fillStyle='#000'; ctx.fillRect(x+6,y+8,4,4); ctx.fillRect(x+e.w-10,y+8,4,4);
  });
  ctx.fillStyle='#f39c12'; eBullets.forEach(b=> ctx.fillRect(b.x-state.camX,b.y-state.camY,b.w,b.h));
  ctx.fillStyle='#2ecc71'; pBullets.forEach(b=> ctx.fillRect(b.x-state.camX,b.y-state.camY,b.w,b.h));
  drawDrops();
  
  if (state.scene === 'playing') {
      ctx.globalAlpha = player.inv>0? 0.5 + 0.5*Math.sin(performance.now()/40) : 1;
      const px=player.x-state.camX, py=player.y-state.camY;
      ctx.fillStyle=getCSS('--player'); ctx.fillRect(px,py+6,player.w,player.h-6);
      ctx.beginPath(); ctx.arc(px+player.w/2, py+6, player.w/2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#fff'; const eyeY=py+2;
      if(player.facing===1){ ctx.fillRect(px+player.w/2, eyeY, 4,4); ctx.fillRect(px+player.w/2+6, eyeY, 4,4); }
      else { ctx.fillRect(px+player.w/2-10, eyeY, 4,4); ctx.fillRect(px+player.w/2-4, eyeY, 4,4); }
      ctx.fillStyle='#000'; ctx.fillRect(px+player.w/2-4, py+player.h-6, 8,2);
      ctx.globalAlpha=1;
  }
}

/* ================ HUD, LOOP, FIT ================ */
function updateHUD(){
  const heart=(lang==='ar'?'‚ù§':'‚ô•'); HUD.hearts.textContent=heart.repeat(state.hearts);
  HUD.shield.textContent='üõ° '+state.shield;
  HUD.stage.textContent=(lang==='ar'?('ŸÖ'+(state.level+1)):('L'+(state.level+1)));
}
let lastT=performance.now();
function loop(t){ const dt=Math.min(0.05,(t-lastT)/1000); lastT=t; if(state.scene==='playing') update(dt); draw(); requestAnimationFrame(loop); }
function fit(){ const s=Math.min(innerWidth/CFG.viewW, innerHeight/CFG.viewH); canvas.style.width=Math.max(320,(CFG.viewW*s)|0)+'px'; canvas.style.height=Math.max(240,(CFG.viewH*s)|0)+'px'; }
addEventListener('resize',fit);

/* ================ INIT ================ */
function init(){
  const has=loadProgress();
  showOverlay(I18N[lang].title, splashHTML(), [
    {label:I18N[lang].start, primary:true, on:()=>{ hideOverlay(); resetRun(); startLevel(0,true); }},
   ...(has?[{label:I18N[lang].cont, on:()=>{ hideOverlay(); startLevel(state.level,true); }}]:[])
  ]);
  setTimeout(renderSplash,0);
}

fit();
init();
requestAnimationFrame(t=>{ lastT=t; loop(t); });

})();
</script>
</body>
</html>

